<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pronunciation Practice</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0f172a;
        --surface: rgba(15, 23, 42, 0.88);
        --accent: #38bdf8;
        --accent-strong: #0ea5e9;
        --text: #e2e8f0;
        --muted: #94a3b8;
        --success: #22c55e;
        --error: #ef4444;
        --close: #f97316;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        min-height: 100vh;
        padding: 3rem 1.5rem 4rem;
        background: var(--bg);
        color: var(--text);
        display: flex;
        justify-content: center;
        align-items: flex-start;
      }

      main {
        width: min(880px, 100%);
        background: var(--surface);
        padding: clamp(2rem, 4vw, 3rem);
        border-radius: 28px;
        box-shadow: 0 24px 48px rgba(15, 23, 42, 0.65);
      }

      h1 {
        margin-top: 0;
        font-size: clamp(2rem, calc(5vw - 0.5rem), 2.75rem);
        line-height: 1.1;
        color: var(--accent);
      }

      .app-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1.25rem;
        flex-wrap: wrap;
        margin-bottom: 1.75rem;
      }

      .app-header h1 {
        margin: 0;
        flex: 1 1 auto;
      }

      p {
        line-height: 1.6;
        margin: 0 0 1rem;
      }

      label,
      select,
      button {
        font-size: 1rem;
      }

      .controls {
        display: grid;
        gap: 1rem;
        margin: 1.5rem 0 2rem;
      }

      .language-toggle {
        display: inline-flex;
        align-items: center;
        background: rgba(148, 163, 184, 0.12);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 999px;
        padding: 0.2rem;
        gap: 0.2rem;
      }

      .language-button {
        border: none;
        background: transparent;
        color: inherit;
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        font-weight: 600;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 120ms ease, color 120ms ease;
      }

      .language-button:hover,
      .language-button:focus-visible {
        background: rgba(148, 163, 184, 0.24);
        outline: none;
      }

      .language-button.active {
        background: var(--accent);
        color: #02131f;
      }

      .control-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .control-row.stack {
        flex-direction: column;
        align-items: stretch;
      }

      .practice-selects {
        display: flex;
        flex-wrap: wrap;
        gap: 0.65rem;
        align-items: center;
      }

      .practice-language {
        display: inline-flex;
        align-items: center;
        gap: 0.45rem;
        flex: 0 1 auto;
        white-space: nowrap;
      }

      .practice-label {
        margin: 0;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        padding: 0.55rem 1.1rem;
        background: rgba(148, 163, 184, 0.12);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 999px;
        cursor: pointer;
        transition: background 120ms ease, border 120ms ease;
      }

      .practice-label:hover,
      .practice-label:focus-visible {
        background: rgba(148, 163, 184, 0.18);
        border-color: rgba(148, 163, 184, 0.45);
        outline: none;
      }

      .practice-selects select {
        flex: 1;
        min-width: 200px;
      }

      .practice-language select {
        flex: 0 1 180px;
        min-width: 170px;
      }

      select,
      button {
        background: rgba(148, 163, 184, 0.12);
        color: inherit;
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 999px;
        padding: 0.65rem 1.25rem;
        transition: background 120ms ease, border 120ms ease, transform 120ms ease;
      }

      select {
        min-width: 220px;
        background-color: rgba(15, 23, 42, 0.88);
        color: var(--text);
        border-color: rgba(148, 163, 184, 0.45);
        box-shadow: inset 0 0 0 1px rgba(56, 189, 248, 0.08);
      }

      select option {
        background-color: #1e293b;
        color: #f8fafc;
      }

      select:focus,
      button:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      button:hover,
      select:hover {
        background: rgba(148, 163, 184, 0.2);
        border-color: rgba(148, 163, 184, 0.45);
      }

      button:active {
        transform: scale(0.98);
      }

      button.practice-button {
        background: var(--success);
        color: #052e16;
        border: none;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      button.practice-button:hover {
        background: #16a34a;
      }

      button[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .text-input-wrapper {
        position: relative;
      }

      .add-custom-button {
        align-self: flex-start;
        background: rgba(56, 189, 248, 0.15);
        border-color: rgba(56, 189, 248, 0.35);
        color: var(--accent);
        font-weight: 600;
      }

      .add-custom-button:hover {
        background: rgba(56, 189, 248, 0.25);
        border-color: rgba(56, 189, 248, 0.55);
      }

      .legend-card {
        position: absolute;
        top: calc(100% + 0.75rem);
        right: 0;
        width: max(260px, 50%);
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 16px;
        padding: 1rem;
        color: var(--text);
        box-shadow: 0 18px 30px rgba(15, 23, 42, 0.55);
        opacity: 0;
        pointer-events: none;
        transform: translateY(-6px);
        transition: opacity 160ms ease, transform 160ms ease;
        font-size: 0.9rem;
        line-height: 1.5;
        z-index: 2;
      }

      .legend-card strong {
        display: block;
        margin-bottom: 0.35rem;
        font-size: 0.95rem;
        color: var(--accent);
      }

      .legend-card ul {
        margin: 0;
        padding-left: 1.1rem;
      }

      .legend-card li {
        margin-bottom: 0.25rem;
      }

      .legend-card.active:hover,
      .legend-card.active:focus {
        opacity: 1;
        transform: translateY(0);
      }

      .text-input-wrapper:hover .legend-card.active,
      .text-input-wrapper:focus-within .legend-card.active {
        opacity: 1;
        transform: translateY(0);
      }

      .paragraph {
        font-size: clamp(1.1rem, 2.5vw, 1.3rem);
        line-height: 1.75;
        padding: 1.5rem;
        border-radius: 20px;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.25);
        min-height: 140px;
        transition: border 200ms ease;
        white-space: pre-wrap;
        outline: none;
        overflow-y: auto;
      }

      .paragraph span {
        padding: 0.15rem 0.1rem;
        border-radius: 6px;
        transition: background 200ms ease, color 200ms ease;
      }

      .paragraph[contenteditable="true"] {
        background: rgba(148, 163, 184, 0.12);
        border: 1px solid rgba(148, 163, 184, 0.25);
      }

      .paragraph[contenteditable="true"]:focus {
        background: rgba(148, 163, 184, 0.18);
        border-color: rgba(148, 163, 184, 0.45);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
      }

      .paragraph[data-placeholder]:empty::before {
        content: attr(data-placeholder);
        color: var(--muted);
      }

      .paragraph.interactive span {
        cursor: pointer;
      }

      .paragraph.interactive span:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .paragraph.interactive span:hover {
        background: rgba(56, 189, 248, 0.15);
      }

      .paragraph span.correct {
        background: rgba(34, 197, 94, 0.2);
        color: var(--success);
      }

      .paragraph span.incorrect {
        background: rgba(239, 68, 68, 0.18);
        color: var(--error);
      }

      .paragraph span.pending {
        background: rgba(148, 163, 184, 0.18);
        color: var(--muted);
      }

      .paragraph span.close {
        background: rgba(249, 115, 22, 0.2);
        color: var(--close);
      }

      .paragraph span.provisional.correct,
      .paragraph span.provisional.incorrect {
        opacity: 0.7;
      }

      .paragraph span.slow {
        box-shadow: inset 0 -0.25rem 0 rgba(250, 204, 21, 0.35);
        color: #facc15;
      }

      .paragraph span.repeated {
        box-shadow: inset 0 -0.25rem 0 rgba(192, 132, 252, 0.45);
        color: #c084fc;
      }

      .status {
        margin-top: 1.5rem;
        display: grid;
        gap: 0.5rem;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .helper-text {
        margin: 0.35rem 0 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .advanced-row {
        justify-content: space-between;
        align-items: center;
      }

      .advanced-row .helper-text {
        margin: 0;
        max-width: 420px;
      }

      .advanced-settings {
        background: rgba(148, 163, 184, 0.12);
        border-radius: 20px;
        padding: 1.25rem;
        display: grid;
        gap: 1rem;
      }

      .advanced-grid {
        display: grid;
        gap: 0.75rem 1rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .advanced-settings .field {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .advanced-settings .field label {
        font-weight: 600;
        color: var(--text);
      }

      .advanced-settings .toggle {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .advanced-settings input[type="checkbox"] {
        width: 1.1rem;
        height: 1.1rem;
        accent-color: var(--accent);
      }

      .status strong {
        color: var(--accent);
      }

      .status .transcript {
        font-family: "Fira Code", "Source Code Pro", monospace;
        white-space: pre-wrap;
        background: rgba(148, 163, 184, 0.12);
        border-radius: 16px;
        padding: 1rem;
        color: var(--text);
      }

      .history {
        margin-top: 2.5rem;
        display: grid;
        gap: 1rem;
      }

      .history-header h2 {
        margin: 0;
        font-size: clamp(1.4rem, 3vw, 1.75rem);
        color: var(--accent);
      }

      .history-header p {
        margin: 0.35rem 0 0;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .history-empty-message {
        margin: 0;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .history-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 1rem;
      }

      .history-card {
        background: rgba(15, 23, 42, 0.7);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 20px;
        padding: 1.25rem;
        display: grid;
        gap: 0.75rem;
      }

      .history-card__header {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        align-items: flex-start;
      }

      .history-card__title {
        margin: 0;
        font-size: 1.1rem;
      }

      .history-card__timestamp {
        margin: 0.25rem 0 0;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .history-card__meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1.5rem;
        align-items: baseline;
      }

      .history-score {
        font-weight: 600;
        color: var(--accent);
      }

      .history-status {
        font-size: 0.95rem;
        color: var(--muted);
      }

      .history-status--perfect {
        color: var(--success);
      }

      .history-status--needs-work {
        color: var(--error);
      }

      .history-words {
        margin: 0;
        padding: 0;
        list-style: none;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .history-word {
        padding: 0.2rem 0.5rem;
        border-radius: 999px;
        font-size: 0.95rem;
        line-height: 1.4;
        background: rgba(148, 163, 184, 0.16);
      }

      .history-word--correct {
        background: rgba(34, 197, 94, 0.22);
        color: var(--success);
      }

      .history-word--close {
        background: rgba(249, 115, 22, 0.22);
        color: var(--close);
      }

      .history-word--incorrect {
        background: rgba(239, 68, 68, 0.22);
        color: var(--error);
      }

      .history-remove {
        background: rgba(239, 68, 68, 0.12);
        border: 1px solid rgba(239, 68, 68, 0.4);
        color: var(--error);
        border-radius: 999px;
        padding: 0.35rem 0.9rem;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 120ms ease, border 120ms ease;
      }

      .history-remove:hover,
      .history-remove:focus-visible {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.55);
        outline: none;
      }

      .history-remove:active {
        transform: scale(0.97);
      }

      .success-modal {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
        z-index: 30;
      }

      .success-modal__content {
        background: linear-gradient(145deg, rgba(34, 197, 94, 0.15), rgba(56, 189, 248, 0.18));
        border: 1px solid rgba(56, 189, 248, 0.4);
        border-radius: 20px;
        padding: 1.75rem 2rem;
        text-align: center;
        box-shadow: 0 24px 48px rgba(15, 23, 42, 0.55);
        min-width: 240px;
        position: relative;
        overflow: hidden;
      }

      .success-modal__emoji {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        position: relative;
        z-index: 1;
      }

      .success-modal__confetti {
        position: absolute;
        inset: -30%;
        background-image:
          radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.45), transparent 35%),
          radial-gradient(circle at 80% 25%, rgba(34, 197, 94, 0.45), transparent 32%),
          radial-gradient(circle at 30% 75%, rgba(236, 72, 153, 0.4), transparent 30%),
          radial-gradient(circle at 70% 80%, rgba(248, 180, 0, 0.45), transparent 34%),
          radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25), transparent 38%);
        opacity: 0.55;
        pointer-events: none;
        mix-blend-mode: screen;
        animation: confettiFloat 12s linear infinite;
      }

      @keyframes confettiFloat {
        0% {
          transform: translateY(0) rotate(0deg);
        }
        50% {
          transform: translateY(-10px) rotate(6deg);
        }
        100% {
          transform: translateY(0) rotate(0deg);
        }
      }

      .success-modal__button {
        background: var(--accent);
        color: #02131f;
        border: none;
        font-weight: 700;
        letter-spacing: 0.01em;
        padding: 0.65rem 1.5rem;
        border-radius: 12px;
        cursor: pointer;
        transition: background 120ms ease, transform 120ms ease;
        position: relative;
        z-index: 1;
      }

      .success-modal__button:hover,
      .success-modal__button:focus-visible {
        background: var(--accent-strong);
        outline: none;
      }

      .success-modal__button:active {
        transform: scale(0.98);
      }

      .hidden {
        display: none !important;
      }

      @media (max-width: 600px) {
        body {
          padding: 2rem 1rem 3rem;
        }

        .control-row {
          flex-direction: column;
          align-items: stretch;
        }

        select,
        button,
        textarea {
          width: 100%;
        }

        .history-card__header {
          flex-direction: column;
          align-items: stretch;
        }

        .history-card__header .history-remove {
          align-self: flex-start;
        }

        .history-words {
          gap: 0.3rem;
        }

        .app-header {
          flex-direction: column;
          align-items: stretch;
          gap: 1rem;
        }

        .language-toggle {
          align-self: flex-start;
        }

        .practice-selects {
          flex-direction: column;
          align-items: stretch;
        }

        .practice-language {
          flex-direction: column;
          align-items: stretch;
          gap: 0.5rem;
        }

        .practice-label {
          justify-content: center;
        }

        .practice-language select {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="app-header">
        <h1 id="appTitle">Pronunciation Practice</h1>
        <div class="language-toggle" role="group" aria-label="Interface language">
          <button
            type="button"
            class="language-button active"
            data-language="en"
          >
            EN
          </button>
          <button
            type="button"
            class="language-button"
            data-language="ca"
          >
            CA
          </button>
        </div>
      </div>
      <div class="controls">
        <div class="control-row stack" id="customTextRow">
          <div class="practice-selects">
            <div class="practice-language">
              <label
                id="practiceLabel"
                class="practice-label"
                for="recognitionLanguage"
              >
                Practise
              </label>
              <select id="recognitionLanguage">
                <option value="en-US" data-transcribe="en">
                  English
                </option>
                <option value="ca-ES" data-transcribe="ca">Catalan</option>
                <option value="fr-FR" data-transcribe="fr">French</option>
              <option value="it-IT" data-transcribe="it">Italian</option>
              <option value="ar-SA" data-transcribe="ar">Arabic</option>
            </select>
            <select
              id="paragraph"
              aria-labelledby="practiceLabel"
            ></select>
          </div>
          <div class="text-input-wrapper">
            <div
              id="customText"
              class="paragraph"
              contenteditable="true"
              data-placeholder="Type or paste the text you want to practise."
              role="textbox"
              aria-live="polite"
              aria-multiline="true"
              aria-label="Practice text"
            ></div>
            <div
              id="legendCard"
              class="legend-card"
              role="note"
              aria-live="polite"
              aria-hidden="true"
            >
              <strong id="legendTitle">Highlight guide</strong>
              <ul>
                <li id="legendCorrect">
                  <span style="color: var(--success); font-weight: 600;">Green</span>
                  words sounded correct.
                </li>
                <li id="legendClose">
                  <span style="color: var(--close); font-weight: 600;">Orange</span>
                  words were close but need a touch more clarity.
                </li>
                <li id="legendIncorrect">
                  <span style="color: var(--error); font-weight: 600;">Red</span> words
                  need another pass.
                </li>
                <li id="legendSlow">
                  <span style="color: #f59e0b; font-weight: 600;">Orange underline</span>
                  marks slower words.
                </li>
                <li id="legendRepeat">
                  <span style="color: #c084fc; font-weight: 600;">Purple underline</span>
                  shows repeated words.
                </li>
              </ul>
            </div>
          </div>
          <p id="customTextHelper" class="helper-text"></p>
          <button id="addCustomText" type="button" class="add-custom-button">
            ‚ûï Add another custom text
          </button>
        </div>
        <div class="control-row">
          <button id="playText" type="button">‚ñ∂Ô∏è Play</button>
          <button id="start" type="button" class="practice-button">
            üé§ Start practice
          </button>
          <button id="stop" type="button" disabled>‚èπ Stop</button>
        </div>
        <div class="control-row advanced-row">
          <button
            id="toggleAdvancedSettings"
            type="button"
            aria-expanded="false"
            aria-controls="advancedSettingsPanel"
          >
            ‚öôÔ∏è Advanced
          </button>
        </div>
        <section
          id="advancedSettingsPanel"
          class="advanced-settings hidden"
          aria-label="Advanced recognition settings"
        >
          <div class="advanced-grid">
            <div class="field">
              <label for="advancedModelSize">Model size</label>
              <select id="advancedModelSize">
                <option value="tiny">Tiny (fastest)</option>
                <option value="base">Base</option>
                <option value="small">Small</option>
                <option value="medium">Medium</option>
                <option value="large-v2" selected>Large v2</option>
              </select>
            </div>
            <div class="field">
              <label for="advancedComputeType">Compute type</label>
              <select id="advancedComputeType">
                <option value="">Model default</option>
                <option value="int8" selected>int8 (CPU friendly)</option>
                <option value="int8_float16">int8 float16</option>
                <option value="int8_float32">int8 float32</option>
                <option value="float16">float16</option>
                <option value="float32">float32</option>
              </select>
            </div>
            <div class="field">
              <label for="ttsVoice">Text-to-speech voice</label>
              <select id="ttsVoice">
                <option value="">Browser default</option>
              </select>
            </div>
          </div>
          <label class="toggle" for="vadFilterToggle">
            <input type="checkbox" id="vadFilterToggle" />
            <span id="vadFilterLabel"
              >Apply voice activity detection (helps trim silence)</span
            >
          </label>
        </section>
      </div>
      <section id="status" class="status">
        <p id="supportMessage" class="hidden"></p>
        <p class="hidden" id="listening">
          Listening‚Ä¶ speak clearly into your microphone.
        </p>
        <p class="hidden" id="processing">Processing recording‚Ä¶</p>
        <div class="hidden" id="result">
          <strong id="transcriptHeading">Recognised transcript</strong>
          <div class="transcript" id="transcript">‚Äî</div>
        </div>
      </section>
      <section id="history" class="history" aria-live="polite">
        <div class="history-header">
          <h2 id="historyHeading">Practice history</h2>
          <p id="historyHelper"></p>
        </div>
        <p id="historyEmpty" class="history-empty-message">
          No practice attempts saved yet.
        </p>
        <ul
          id="historyList"
          class="history-list"
          aria-label="Saved practice results"
        ></ul>
      </section>
    </main>

    <div
      id="successModal"
      class="success-modal hidden"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-label="Practice complete"
    >
      <div class="success-modal__content">
        <div class="success-modal__confetti" aria-hidden="true"></div>
        <div class="success-modal__emoji" aria-hidden="true">üëè</div>
        <button type="button" id="successModalClose" class="success-modal__button">
          ‚úåÔ∏è
        </button>
      </div>
    </div>

    <script>
      const htmlElement = document.documentElement;
      const appTitle = document.getElementById("appTitle");
      const languageToggle = document.querySelector(".language-toggle");
      const languageButtons = Array.from(
        document.querySelectorAll(".language-button"),
      );
      const practiceLabelEl = document.getElementById("practiceLabel");
      const paragraphSelect = document.getElementById("paragraph");
      const customTextRow = document.getElementById("customTextRow");
      const customTextInput = document.getElementById("customText");
      const helperText = customTextRow.querySelector(".helper-text");
      const addCustomTextButton = document.getElementById("addCustomText");
      const playTextButton = document.getElementById("playText");
      const startButton = document.getElementById("start");
      const stopButton = document.getElementById("stop");
      const advancedSettingsToggle = document.getElementById(
        "toggleAdvancedSettings",
      );
      const advancedSettingsPanel = document.getElementById(
        "advancedSettingsPanel",
      );
      const advancedModelSizeSelect = document.getElementById(
        "advancedModelSize",
      );
      const advancedComputeTypeSelect = document.getElementById(
        "advancedComputeType",
      );
      const advancedModelSizeLabel = document.querySelector(
        'label[for="advancedModelSize"]',
      );
      const advancedComputeTypeLabel = document.querySelector(
        'label[for="advancedComputeType"]',
      );
      const ttsVoiceLabelEl = document.querySelector('label[for="ttsVoice"]');
      const ttsVoiceSelect = document.getElementById("ttsVoice");
      const recognitionLanguageSelect = document.getElementById(
        "recognitionLanguage",
      );
      const vadFilterLabelEl = document.getElementById("vadFilterLabel");
      const vadFilterToggle = document.getElementById("vadFilterToggle");
      const listeningLabel = document.getElementById("listening");
      const processingLabel = document.getElementById("processing");
      const resultContainer = document.getElementById("result");
      const transcriptEl = document.getElementById("transcript");
      const supportMessage = document.getElementById("supportMessage");
      const transcriptHeadingEl = document.getElementById("transcriptHeading");
      const legendCard = document.getElementById("legendCard");
      const legendTitleEl = document.getElementById("legendTitle");
      const legendCorrectEl = document.getElementById("legendCorrect");
      const legendCloseEl = document.getElementById("legendClose");
      const legendIncorrectEl = document.getElementById("legendIncorrect");
      const legendSlowEl = document.getElementById("legendSlow");
      const legendRepeatEl = document.getElementById("legendRepeat");
      const historySection = document.getElementById("history");
      const historyHeadingEl = document.getElementById("historyHeading");
      const historyHelperEl = document.getElementById("historyHelper");
      const historyEmptyEl = document.getElementById("historyEmpty");
      const historyListEl = document.getElementById("historyList");
      const successModal = document.getElementById("successModal");
      const successModalClose = document.getElementById("successModalClose");

      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition || null;
      const supportsSpeechRecognition = typeof SpeechRecognition === "function";
      const supportsSpeechSynthesis =
        typeof window !== "undefined" &&
        "speechSynthesis" in window &&
        typeof SpeechSynthesisUtterance !== "undefined";
      const synth = supportsSpeechSynthesis ? window.speechSynthesis : null;
      let voiceRetryTimeoutId = null;
      const SLOW_WORD_THRESHOLD_MS = 2500;
      const CLOSE_SIMILARITY_THRESHOLD = 0.5;
      const MATCH_LOOKAHEAD_LIMIT = 6;
      const CUSTOM_OPTION_ID = "custom";
      const ADVANCED_CONFIG_STORAGE_KEY = "speechtoipa:advanced-config";
      const PRACTICE_HISTORY_STORAGE_KEY = "speechtoipa:practice-history";

      const defaultRecognitionLocale =
        navigator.language && typeof navigator.language === "string"
          ? navigator.language
          : "en-US";
      const defaultTranscriptionLanguage =
        defaultRecognitionLocale.split("-")[0] || "en";

      const UI_LANGUAGE_STORAGE_KEY = "speechtoipa:ui-language";

      const translations = {
        en: {
          documentTitle: "Pronunciation Practice",
          appHeading: "Pronunciation Practice",
          interfaceLanguageAriaLabel: "Interface language",
          interfaceLanguageEnglish: "EN",
          interfaceLanguageCatalan: "CA",
          practiceLabel: "Practise",
          paragraphSelectAria: "Choose a practice passage",
          customTextAria: "Practice text editor",
          customTextPlaceholder: "Type or paste the text you want to practise.",
          customHelper: "",
          customSavedHelper:
            "This saved text is editable below. Use the dropdown to switch between your custom passages.",
          presetHelper:
            "This passage comes from the list above. Select ‚ÄúCustom text‚Äù to enter your own.",
          addCustomText: "‚ûï Add another custom text",
          playButtonLabel: "‚ñ∂Ô∏è Play",
          startButtonLabel: "üé§ Start practice",
          stopButtonLabel: "‚èπ Stop",
          advancedToggleShow: "‚öôÔ∏è Advanced",
          advancedToggleHide: "‚öôÔ∏è Hide advanced",
          modelSizeLabel: "Model size",
          computeTypeLabel: "Compute type",
          ttsVoiceLabel: "Text-to-speech voice",
          ttsVoiceDefault: "Browser default",
          ttsVoiceUnavailable: "Speech synthesis unavailable",
          vadLabel: "Apply voice activity detection (helps trim silence)",
          listening: "Listening‚Ä¶ speak clearly into your microphone.",
          processing: "Processing recording‚Ä¶",
          transcriptHeading: "Recognised transcript",
          legendTitle: "Highlight guide",
          legendCorrect:
            '<span style="color: var(--success); font-weight: 600;">Green</span> words sounded correct.',
          legendClose:
            '<span style="color: var(--close); font-weight: 600;">Orange</span> words were close but need a touch more clarity.',
          legendIncorrect:
            '<span style="color: var(--error); font-weight: 600;">Red</span> words need another pass.',
          legendSlow:
            '<span style="color: #f59e0b; font-weight: 600;">Orange underline</span> marks slower words.',
          legendRepeat:
            '<span style="color: #c084fc; font-weight: 600;">Purple underline</span> shows repeated words.',
          legendHelper: "Click a highlighted word to hear it pronounced again.",
          customPlaceholder: "Type or paste your own practice text in the box above.",
          customDefaultLabel: "Custom text (enter below)",
          customNumberedLabel: (n) => `Custom text ${n}`,
          playButtonTitleNoSpeech:
            "Speech synthesis is unavailable in this browser.",
          playButtonTitleRecording:
            "Finish the current recording before playing the text aloud.",
          playButtonTitleMissingText:
            "Enter or select some text to play it aloud.",
          playButtonTitleReady: "Play the current practice text aloud.",
          recognitionUnavailable:
            "Speech recognition is unavailable in this browser.",
          microphonePermissionDenied:
            "Microphone permission was denied. Please allow access and try again.",
          speechRecognitionIssue: "Speech recognition encountered an issue.",
          speechRecognitionStartError:
            "Speech recognition could not be started.",
          mediaRecorderUnsupported:
            "MediaRecorder is not supported in this browser. Try a modern Chromium-based browser.",
          microphoneUnavailable: "Unable to access the microphone.",
          recorderFailed: "Failed to start audio recorder.",
          wordPronunciation: (word) => `Hear model pronunciation for ‚Äú${word}‚Äù.`,
          wordGeneric: (word) => `Word ‚Äú${word}‚Äù.`,
          feedbackCorrect: "Pronounced correctly.",
          feedbackClose: "Close match‚Äîsounds similar but could be clearer.",
          feedbackIncorrect: "Did not match the expected pronunciation.",
          feedbackPending: "Awaiting pronunciation.",
          feedbackProvisional: "Result is provisional.",
          feedbackSlow: "Spoken slowly.",
          feedbackRepeated: "Repeated word.",
          transcriptPlaceholder: "‚Äî",
          transcriptPending: "‚Ä¶",
          customTextRequired:
            "Enter or paste the text you want to practise before starting a recording.",
          noAudioCaptured: "No audio was captured. Please try again.",
          processingErrorFallback:
            "Something went wrong while processing the recording.",
          transcriptionRequestFailed: "Transcription request failed",
          noSpeechRecognised: "No speech was recognised. Please try again.",
          recognitionOptionEn: "English",
          recognitionOptionCa: "Catalan",
          recognitionOptionFr: "French",
          recognitionOptionIt: "Italian",
          recognitionOptionAr: "Arabic",
          historyHeading: "Practice history",
          historyHelper: "",
          historyEmpty: "No practice attempts saved yet.",
          historyListLabel: "Saved practice results",
          historyPractisedOn: (datetime) => `Practised on ${datetime}`,
          historySuccessRate: (percent) => `Success rate: ${percent}%`,
          historyPerfect: "Completed with 100% accuracy.",
          historyNeedsWork: "Needs more practice on the highlighted words.",
          historyRemove: "Remove",
          historyRemoveAria: (label) => `Remove saved result for ${label}`,
          historyWordsLabel: "Pronunciation feedback by word",
          historyWordCorrect: "Correct pronunciation",
          historyWordClose: "Close pronunciation",
          historyWordIncorrect: "Needs more practice",
        },
        ca: {
          documentTitle: "Pr√†ctica de pronunciaci√≥",
          appHeading: "Pr√†ctica de pronunciaci√≥",
          interfaceLanguageAriaLabel: "Idioma de la interf√≠cie",
          interfaceLanguageEnglish: "EN",
          interfaceLanguageCatalan: "CA",
          practiceLabel: "Practica",
          paragraphSelectAria: "Tria un fragment de pr√†ctica",
          customTextAria: "Editor de text de pr√†ctica",
          customTextPlaceholder: "Escriu o enganxa el text amb qu√® vols practicar.",
          customHelper: "",
          customSavedHelper:
            "Aquest text desat es pot editar a continuaci√≥. Utilitza el desplegable per canviar entre els teus textos personalitzats.",
          presetHelper:
            "Aquest fragment prov√© de la llista anterior. Selecciona ‚ÄúText personalitzat‚Äù per introduir el teu propi.",
          addCustomText: "‚ûï Afegeix un altre text personalitzat",
          playButtonLabel: "‚ñ∂Ô∏è Reprodueix",
          startButtonLabel: "üé§ Comen√ßa la pr√†ctica",
          stopButtonLabel: "‚èπ Atura",
          advancedToggleShow: "‚öôÔ∏è Opcions avan√ßades",
          advancedToggleHide: "‚öôÔ∏è Amaga les opcions avan√ßades",
          modelSizeLabel: "Mida del model",
          computeTypeLabel: "Tipus de c√≤mput",
          ttsVoiceLabel: "Veu de text a veu",
          ttsVoiceDefault: "Per defecte del navegador",
          ttsVoiceUnavailable: "S√≠ntesi de veu no disponible",
          vadLabel:
            "Aplica detecci√≥ d'activitat vocal (ajuda a retallar silencis)",
          listening: "Escoltant‚Ä¶ parla amb claredat al micr√≤fon.",
          processing: "Processant la gravaci√≥‚Ä¶",
          transcriptHeading: "Transcripci√≥ reconeguda",
          legendTitle: "Guia de ressaltat",
          legendCorrect:
            '<span style="color: var(--success); font-weight: 600;">Verd</span> indica que les paraules han sonat correctes.',
          legendClose:
            '<span style="color: var(--close); font-weight: 600;">Taronja</span> indica paraules semblants per√≤ que necessiten una mica m√©s de claredat.',
          legendIncorrect:
            '<span style="color: var(--error); font-weight: 600;">Vermell</span> indica paraules que cal repetir.',
          legendSlow:
            '<span style="color: #f59e0b; font-weight: 600;">Subratllat taronja</span> marca paraules m√©s lentes.',
          legendRepeat:
            '<span style="color: #c084fc; font-weight: 600;">Subratllat lila</span> mostra paraules repetides.',
          legendHelper: "Fes clic a una paraula ressaltada per tornar-la a escoltar.",
          customPlaceholder:
            "Escriu o enganxa el teu propi text de pr√†ctica al quadre superior.",
          customDefaultLabel: "Text personalitzat (escriu-lo a continuaci√≥)",
          customNumberedLabel: (n) => `Text personalitzat ${n}`,
          playButtonTitleNoSpeech:
            "La s√≠ntesi de veu no est√† disponible en aquest navegador.",
          playButtonTitleRecording:
            "Acaba la gravaci√≥ actual abans de reproduir el text en veu alta.",
          playButtonTitleMissingText:
            "Introdueix o selecciona un text per reproduir-lo en veu alta.",
          playButtonTitleReady:
            "Reprodueix en veu alta el text de pr√†ctica actual.",
          recognitionUnavailable:
            "El reconeixement de veu no est√† disponible en aquest navegador.",
          microphonePermissionDenied:
            "S'ha denegat el perm√≠s del micr√≤fon. Permet-ne l'acc√©s i torna-ho a provar.",
          speechRecognitionIssue:
            "Hi ha hagut un problema amb el reconeixement de veu.",
          speechRecognitionStartError:
            "No s'ha pogut iniciar el reconeixement de veu.",
          mediaRecorderUnsupported:
            "El MediaRecorder no √©s compatible amb aquest navegador. Prova amb un navegador modern basat en Chromium.",
          microphoneUnavailable: "No s'ha pogut accedir al micr√≤fon.",
          recorderFailed: "No s'ha pogut iniciar l'enregistrador d'√†udio.",
          wordPronunciation: (word) =>
            `Escolta la pronunciaci√≥ del model de ‚Äú${word}‚Äù.`,
          wordGeneric: (word) => `Paraula ‚Äú${word}‚Äù.`,
          feedbackCorrect: "Pronunciada correctament.",
          feedbackClose:
            "Coincid√®ncia propera‚Äîsona semblant per√≤ podria ser m√©s clara.",
          feedbackIncorrect:
            "No coincideix amb la pronunciaci√≥ esperada.",
          feedbackPending: "Esperant la pronunciaci√≥.",
          feedbackProvisional: "El resultat √©s provisional.",
          feedbackSlow: "Pronunciada lentament.",
          feedbackRepeated: "Paraula repetida.",
          transcriptPlaceholder: "‚Äî",
          transcriptPending: "‚Ä¶",
          customTextRequired:
            "Introdueix o enganxa el text amb qu√® vols practicar abans de comen√ßar a gravar.",
          noAudioCaptured: "No s'ha capturat cap √†udio. Torna-ho a provar.",
          processingErrorFallback:
            "S'ha produ√Øt un error en processar la gravaci√≥.",
          transcriptionRequestFailed: "La sol¬∑licitud de transcripci√≥ ha fallat",
          noSpeechRecognised: "No s'ha reconegut cap veu. Torna-ho a provar.",
          recognitionOptionEn: "Angl√®s",
          recognitionOptionCa: "Catal√†",
          recognitionOptionFr: "Franc√®s",
          recognitionOptionIt: "Itali√†",
          recognitionOptionAr: "√Ärab",
          historyHeading: "Historial de pr√†ctica",
          historyHelper: "",
          historyEmpty: "Encara no hi ha intents desats.",
          historyListLabel: "Resultats de pr√†ctica desats",
          historyPractisedOn: (datetime) => `Practicat el ${datetime}`,
          historySuccessRate: (percent) =>
            `Percentatge d'encert: ${percent}%`,
          historyPerfect: "Completat amb una precisi√≥ del 100%.",
          historyNeedsWork: "Cal seguir practicant les paraules ressaltades.",
          historyRemove: "Elimina",
          historyRemoveAria: (label) => `Elimina el resultat desat per ${label}`,
          historyWordsLabel: "Retorn de pronunciaci√≥ per paraula",
          historyWordCorrect: "Pronunciaci√≥ correcta",
          historyWordClose: "Pronunciaci√≥ aproximada",
          historyWordIncorrect: "Cal m√©s pr√†ctica",
        },
      };

      function loadUiLanguage() {
        if (typeof localStorage !== "undefined") {
          try {
            const stored = localStorage.getItem(UI_LANGUAGE_STORAGE_KEY);
            if (stored && translations[stored]) {
              return stored;
            }
          } catch (error) {
            console.warn("Failed to read stored UI language", error);
          }
        }

        const browserLang =
          (navigator.language || navigator.userLanguage || "en")
            .toLowerCase()
            .slice(0, 2);
        if (translations[browserLang]) {
          return browserLang;
        }
        return "en";
      }

      function persistUiLanguage(lang) {
        if (typeof localStorage === "undefined") {
          return;
        }
        try {
          localStorage.setItem(UI_LANGUAGE_STORAGE_KEY, lang);
        } catch (error) {
          console.warn("Failed to persist UI language", error);
        }
      }

      let uiLanguage = loadUiLanguage();

      function t(key, arg) {
        const pack = translations[uiLanguage] || translations.en;
        const fallback = translations.en;
        let value = pack[key];
        if (typeof value === "undefined") {
          value = fallback[key];
        }
        if (typeof value === "function") {
          return value(arg);
        }
        return value;
      }

      function loadPracticeHistory() {
        if (typeof localStorage === "undefined") {
          return [];
        }
        try {
          const raw = localStorage.getItem(PRACTICE_HISTORY_STORAGE_KEY);
          if (!raw) {
            return [];
          }
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) {
            return [];
          }
          return parsed
            .map((entry) => {
              if (!entry || typeof entry !== "object") {
                return null;
              }
              if (!entry.key || typeof entry.key !== "string") {
                return null;
              }
              const words = Array.isArray(entry.words)
                ? entry.words
                    .map((word) => {
                      if (!word || typeof word !== "object") return null;
                      const text = typeof word.text === "string" ? word.text : "";
                      if (!text) return null;
                      const correctness =
                        word.correctness === "correct" ||
                        word.correctness === "close" ||
                        word.correctness === "incorrect"
                          ? word.correctness
                          : "incorrect";
                      return { text, correctness };
                    })
                    .filter(Boolean)
                : [];
              const timestamp =
                typeof entry.timestamp === "string"
                  ? entry.timestamp
                  : new Date().toISOString();
              const successRate =
                typeof entry.successRate === "number" && Number.isFinite(entry.successRate)
                  ? Math.max(0, Math.min(100, Math.round(entry.successRate)))
                  : 0;
              return {
                key: entry.key,
                paragraphId:
                  typeof entry.paragraphId === "string" ? entry.paragraphId : "",
                label: typeof entry.label === "string" ? entry.label : "",
                preview: typeof entry.preview === "string" ? entry.preview : "",
                text: typeof entry.text === "string" ? entry.text : "",
                timestamp,
                successRate,
                words,
              };
            })
            .filter(Boolean);
        } catch (error) {
          console.warn("Failed to read practice history", error);
          return [];
        }
      }

      function persistPracticeHistory(entries) {
        if (typeof localStorage === "undefined") {
          return;
        }
        try {
          localStorage.setItem(
            PRACTICE_HISTORY_STORAGE_KEY,
            JSON.stringify(entries),
          );
        } catch (error) {
          console.warn("Failed to persist practice history", error);
        }
      }

      function normalisePracticeText(text) {
        return (text || "").replace(/\s+/g, " ").trim();
      }

      function generatePracticeKey(text) {
        let normalised = normalisePracticeText(text).toLowerCase();
        try {
          normalised = normalised.normalize("NFKD");
        } catch (error) {
          // Ignore normalisation errors on environments without full Intl support
        }
        if (!normalised) {
          return "";
        }
        let hash = 0;
        for (let i = 0; i < normalised.length; i += 1) {
          hash = (hash * 31 + normalised.charCodeAt(i)) >>> 0;
        }
        return `text-${normalised.length}-${hash.toString(16)}`;
      }

      let practiceHistoryEntries = loadPracticeHistory();
      practiceHistoryEntries.sort((a, b) => {
        const aTime = Date.parse(a?.timestamp || "") || 0;
        const bTime = Date.parse(b?.timestamp || "") || 0;
        return bTime - aTime;
      });

      function createPracticeSummary(paragraph, tokens, analysis) {
        if (!paragraph) {
          return null;
        }
        const textSource = typeof paragraph.text === "string" ? paragraph.text : "";
        const key = generatePracticeKey(textSource);
        if (!key) {
          return null;
        }
        if (!Array.isArray(tokens) || !tokens.length) {
          return null;
        }
        const words = tokens
          .map((token, idx) => {
            if (!token || typeof token !== "object") {
              return null;
            }
            const original =
              typeof token.original === "string" && token.original
                ? token.original
                : typeof token.cleaned === "string"
                ? token.cleaned
                : "";
            if (!original) {
              return null;
            }
            const status = analysis[idx] || createEmptyStatus();
            let correctness = status.correctness;
            if (correctness === "correct") {
              correctness = "correct";
            } else if (correctness === "close") {
              correctness = "close";
            } else {
              correctness = "incorrect";
            }
            return { text: original, correctness };
          })
          .filter(Boolean);

        if (!words.length) {
          return null;
        }

        const totalWords = words.length;
        const correctWords = words.filter((word) => word.correctness === "correct").length;
        const successRate = totalWords
          ? Math.round((correctWords / totalWords) * 100)
          : 0;

        const normalisedText = normalisePracticeText(textSource);
        const previewText =
          normalisedText.length > 160
            ? `${normalisedText.slice(0, 160)}‚Ä¶`
            : normalisedText;
        const labelSource =
          typeof paragraph.label === "string" && paragraph.label.trim()
            ? paragraph.label
            : "";

        return {
          key,
          paragraphId: typeof paragraph.id === "string" ? paragraph.id : "",
          label: labelSource || previewText || normalisedText || t("customDefaultLabel"),
          preview: previewText,
          text: textSource,
          timestamp: new Date().toISOString(),
          successRate: Math.max(0, Math.min(100, successRate)),
          words,
        };
      }

      function upsertPracticeHistoryEntry(entry) {
        if (!entry || !entry.key) {
          return;
        }
        const existing = practiceHistoryEntries.filter(
          (item) => item && item.key !== entry.key,
        );
        practiceHistoryEntries = [entry, ...existing].sort((a, b) => {
          const aTime = Date.parse(a.timestamp || "") || 0;
          const bTime = Date.parse(b.timestamp || "") || 0;
          return bTime - aTime;
        });
        persistPracticeHistory(practiceHistoryEntries);
        renderPracticeHistory();
      }

      function removePracticeHistoryEntry(key) {
        if (!key) {
          return;
        }
        practiceHistoryEntries = practiceHistoryEntries.filter(
          (entry) => entry && entry.key !== key,
        );
        persistPracticeHistory(practiceHistoryEntries);
        renderPracticeHistory();
      }

      function formatHistoryTimestamp(timestamp) {
        if (!timestamp) {
          return "";
        }
        try {
          const date = new Date(timestamp);
          if (Number.isNaN(date.getTime())) {
            return "";
          }
          const locale = uiLanguage === "ca" ? "ca-ES" : "en-US";
          return new Intl.DateTimeFormat(locale, {
            dateStyle: "medium",
            timeStyle: "short",
          }).format(date);
        } catch (error) {
          return "";
        }
      }

      function getHistoryStatusDescription(status) {
        if (status === "correct") {
          return t("historyWordCorrect");
        }
        if (status === "close") {
          return t("historyWordClose");
        }
        return t("historyWordIncorrect");
      }

      function renderPracticeHistory() {
        if (!historyListEl || !historyEmptyEl) {
          return;
        }

        historyListEl.innerHTML = "";
        const listLabel = t("historyListLabel");
        if (listLabel && historyListEl) {
          historyListEl.setAttribute("aria-label", listLabel);
        }

        if (!practiceHistoryEntries.length) {
          historyEmptyEl.textContent = t("historyEmpty");
          historyEmptyEl.classList.remove("hidden");
          return;
        }

        historyEmptyEl.classList.add("hidden");

        const entries = practiceHistoryEntries
          .slice()
          .sort((a, b) => {
            const aTime = Date.parse(a.timestamp || "") || 0;
            const bTime = Date.parse(b.timestamp || "") || 0;
            return bTime - aTime;
          });

        entries.forEach((entry) => {
          const listItem = document.createElement("li");
          listItem.className = "history-card";
          listItem.dataset.entryKey = entry.key;
          listItem.tabIndex = 0;
          listItem.setAttribute("role", "button");

          const header = document.createElement("div");
          header.className = "history-card__header";

          const titleWrapper = document.createElement("div");
          const title = document.createElement("h3");
          title.className = "history-card__title";
          title.textContent = entry.label || entry.preview || t("customDefaultLabel");
          titleWrapper.append(title);

          const timestampText = formatHistoryTimestamp(entry.timestamp);
          if (timestampText) {
            const timestampEl = document.createElement("p");
            timestampEl.className = "history-card__timestamp";
            timestampEl.textContent = t("historyPractisedOn", timestampText);
            titleWrapper.append(timestampEl);
          }

          header.append(titleWrapper);

          const removeButton = document.createElement("button");
          removeButton.type = "button";
          removeButton.className = "history-remove";
          removeButton.dataset.entryKey = entry.key;
          removeButton.textContent = t("historyRemove");
          const ariaTarget = entry.label || entry.preview || t("customDefaultLabel");
          removeButton.setAttribute("aria-label", t("historyRemoveAria", ariaTarget));
          header.append(removeButton);

          listItem.append(header);

          const meta = document.createElement("div");
          meta.className = "history-card__meta";

          const score = document.createElement("span");
          score.className = "history-score";
          score.textContent = t("historySuccessRate", entry.successRate);
          meta.append(score);

          const statusEl = document.createElement("span");
          const statusKey = entry.successRate === 100 ? "perfect" : "needs-work";
          statusEl.className = `history-status history-status--${statusKey}`;
          statusEl.textContent =
            entry.successRate === 100 ? t("historyPerfect") : t("historyNeedsWork");
          meta.append(statusEl);

          listItem.append(meta);

          const words = Array.isArray(entry.words) ? entry.words : [];
          if (words.length) {
            const wordList = document.createElement("ul");
            wordList.className = "history-words";
            wordList.setAttribute("aria-label", t("historyWordsLabel"));
            words.forEach((word) => {
              if (!word || typeof word !== "object") {
                return;
              }
              const statusClass =
                word.correctness === "correct"
                  ? "correct"
                  : word.correctness === "close"
                  ? "close"
                  : "incorrect";
              const item = document.createElement("li");
              item.className = `history-word history-word--${statusClass}`;
              item.textContent = word.text;
              item.setAttribute(
                "aria-label",
                `${word.text} ‚Äì ${getHistoryStatusDescription(statusClass)}`,
              );
              wordList.append(item);
            });
            listItem.append(wordList);
          }

          historyListEl.append(listItem);
        });
      }

      function recordPracticeHistory(paragraph, tokens, analysis) {
        const summary = createPracticeSummary(paragraph, tokens, analysis);
        if (!summary) {
          return;
        }
        upsertPracticeHistoryEntry(summary);
      }

      function createCustomEntry(id, type = "base", order = 1) {
        return {
          id,
          type,
          order,
          get label() {
            if (this.type === "base") {
              return t("customDefaultLabel");
            }
            if (this.type === "saved") {
              return t("customNumberedLabel", this.order);
            }
            return "";
          },
          get helperText() {
            if (this.type === "base") {
              return t("customHelper");
            }
            if (this.type === "saved") {
              return t("customSavedHelper");
            }
            return "";
          },
          get placeholder() {
            return t("customPlaceholder");
          },
        };
      }

      function updateLanguageButtonStates() {
        if (!languageButtons || languageButtons.length === 0) {
          return;
        }
        languageButtons.forEach((button) => {
          const buttonLang = button.dataset.language || "en";
          if (buttonLang === "en") {
            button.textContent = t("interfaceLanguageEnglish");
          } else if (buttonLang === "ca") {
            button.textContent = t("interfaceLanguageCatalan");
          }
          button.classList.toggle("active", buttonLang === uiLanguage);
          button.setAttribute(
            "aria-pressed",
            buttonLang === uiLanguage ? "true" : "false",
          );
        });
      }

      function applyRecognitionLanguageLabels() {
        if (!recognitionLanguageSelect) {
          return;
        }
        const optionLabels = {
          "en-US": t("recognitionOptionEn"),
          "ca-ES": t("recognitionOptionCa"),
          "fr-FR": t("recognitionOptionFr"),
          "it-IT": t("recognitionOptionIt"),
          "ar-SA": t("recognitionOptionAr"),
        };
        Array.from(recognitionLanguageSelect.options).forEach((option) => {
          const label = optionLabels[option.value];
          if (label) {
            option.textContent = label;
          }
        });
      }

      function updateAdvancedToggleText() {
        if (!advancedSettingsToggle || !advancedSettingsPanel) {
          return;
        }
        const isHidden = advancedSettingsPanel.classList.contains("hidden");
        advancedSettingsToggle.setAttribute(
          "aria-expanded",
          isHidden ? "false" : "true",
        );
        advancedSettingsToggle.textContent = isHidden
          ? t("advancedToggleShow")
          : t("advancedToggleHide");
      }

      function applyStaticTranslations() {
        if (htmlElement) {
          htmlElement.lang = uiLanguage;
        }
        document.title = t("documentTitle");
        if (appTitle) {
          appTitle.textContent = t("appHeading");
        }
        if (languageToggle) {
          languageToggle.setAttribute(
            "aria-label",
            t("interfaceLanguageAriaLabel"),
          );
        }
        updateLanguageButtonStates();
        if (practiceLabelEl) {
          practiceLabelEl.textContent = t("practiceLabel");
        }
        if (addCustomTextButton) {
          addCustomTextButton.textContent = t("addCustomText");
        }
        if (playTextButton) {
          playTextButton.textContent = t("playButtonLabel");
        }
        if (startButton) {
          startButton.textContent = t("startButtonLabel");
        }
        if (stopButton) {
          stopButton.textContent = t("stopButtonLabel");
        }
        if (advancedModelSizeLabel) {
          advancedModelSizeLabel.textContent = t("modelSizeLabel");
        }
        if (advancedComputeTypeLabel) {
          advancedComputeTypeLabel.textContent = t("computeTypeLabel");
        }
        if (ttsVoiceLabelEl) {
          ttsVoiceLabelEl.textContent = t("ttsVoiceLabel");
        }
        if (vadFilterLabelEl) {
          vadFilterLabelEl.textContent = t("vadLabel");
        }
        if (listeningLabel) {
          listeningLabel.textContent = t("listening");
        }
        if (processingLabel) {
          processingLabel.textContent = t("processing");
        }
        if (transcriptHeadingEl) {
          transcriptHeadingEl.textContent = t("transcriptHeading");
        }
        if (legendTitleEl) {
          legendTitleEl.textContent = t("legendTitle");
        }
        if (legendCorrectEl) {
          legendCorrectEl.innerHTML = t("legendCorrect");
        }
        if (legendCloseEl) {
          legendCloseEl.innerHTML = t("legendClose");
        }
        if (legendIncorrectEl) {
          legendIncorrectEl.innerHTML = t("legendIncorrect");
        }
        if (legendSlowEl) {
          legendSlowEl.innerHTML = t("legendSlow");
        }
        if (legendRepeatEl) {
          legendRepeatEl.innerHTML = t("legendRepeat");
        }
        applyRecognitionLanguageLabels();
        updateAdvancedToggleText();

        if (historyHeadingEl) {
          historyHeadingEl.textContent = t("historyHeading");
        }
        if (historyHelperEl) {
          historyHelperEl.textContent = t("historyHelper");
        }
        if (historyEmptyEl) {
          historyEmptyEl.textContent = t("historyEmpty");
        }
        if (historyListEl) {
          const listLabel = t("historyListLabel");
          if (listLabel) {
            historyListEl.setAttribute("aria-label", listLabel);
          }
        }
        renderPracticeHistory();

        if (customTextInput) {
          customTextInput.setAttribute("aria-label", t("customTextAria"));
          if (helperText) {
            if (customTextInput.classList.contains("interactive")) {
              helperText.textContent = t("legendHelper");
            } else {
              const selected = getSelectedParagraph();
              if (selected && isCustomParagraphId(selected.id)) {
                const entry = getCustomEntryById(selected.id);
                if (entry) {
                  customTextInput.dataset.placeholder = entry.placeholder;
                  helperText.textContent = entry.helperText;
                }
              } else {
                customTextInput.dataset.placeholder = "";
                helperText.textContent = t("presetHelper");
              }
            }
          }
        }

        if (paragraphSelect) {
          const ariaLabel = t("paragraphSelectAria");
          if (ariaLabel) {
            paragraphSelect.setAttribute("aria-label", ariaLabel);
          } else {
            paragraphSelect.removeAttribute("aria-label");
          }
        }

        if (transcriptEl) {
          const placeholderValues = [
            translations.en.transcriptPlaceholder,
            translations.ca.transcriptPlaceholder,
          ];
          const pendingValues = [
            translations.en.transcriptPending,
            translations.ca.transcriptPending,
          ];
          const current = (transcriptEl.textContent || "").trim();
          if (placeholderValues.includes(current)) {
            transcriptEl.textContent = t("transcriptPlaceholder");
          } else if (pendingValues.includes(current)) {
            transcriptEl.textContent = t("transcriptPending");
          }
        }

        updatePlayButtonState();
      }

      function setUiLanguage(lang) {
        const nextLanguage = translations[lang] ? lang : "en";
        if (uiLanguage === nextLanguage) {
          updateLanguageButtonStates();
          updateAdvancedToggleText();
          return;
        }
        uiLanguage = nextLanguage;
        persistUiLanguage(nextLanguage);
        const currentSelection =
          activeParagraphId || paragraphSelect?.value || CUSTOM_OPTION_ID;
        applyStaticTranslations();
        rebuildParagraphOptions(currentSelection);
        if (recognitionState && recognitionState.targetText) {
          const existingAnalysis = Array.isArray(recognitionState.lockedAnalysis)
            ? recognitionState.lockedAnalysis.map((entry) =>
                entry ? { ...entry } : createEmptyStatus(),
              )
            : [];
          renderParagraph(recognitionState.targetText, existingAnalysis);
        } else {
          displaySelectedParagraph();
        }
        updatePlayButtonState();
      }

      const defaultAdvancedConfig = {
        modelSize: "large-v2",
        computeType: "int8",
        recognitionLocale: defaultRecognitionLocale,
        language: defaultTranscriptionLanguage,
        vadFilter: true,
        ttsVoice: "",
      };

      function loadAdvancedConfig() {
        let storedConfig = null;
        if (typeof localStorage !== "undefined") {
          try {
            const raw = localStorage.getItem(ADVANCED_CONFIG_STORAGE_KEY);
            if (raw) {
              storedConfig = JSON.parse(raw);
            }
          } catch (error) {
            console.warn("Failed to read advanced settings", error);
          }
        }

        const config = {
          ...defaultAdvancedConfig,
          ...(storedConfig && typeof storedConfig === "object" ? storedConfig : {}),
        };

        delete config.device;
        delete config.ipaLanguage;

        config.vadFilter = storedConfig?.vadFilter !== false;
        const hasStoredComputeType =
          storedConfig && Object.prototype.hasOwnProperty.call(storedConfig, "computeType");
        if (!hasStoredComputeType || !config.computeType) {
          config.computeType = defaultAdvancedConfig.computeType;
        }

        if (!config.recognitionLocale) {
          config.recognitionLocale = defaultAdvancedConfig.recognitionLocale;
        }
        if (!config.language) {
          config.language = defaultAdvancedConfig.language;
        }

        return config;
      }

      function persistAdvancedConfig(config) {
        if (typeof localStorage === "undefined") {
          return;
        }

        try {
          localStorage.setItem(
            ADVANCED_CONFIG_STORAGE_KEY,
            JSON.stringify(config),
          );
        } catch (error) {
          console.warn("Failed to persist advanced settings", error);
        }
      }

      let advancedConfig = loadAdvancedConfig();

      function updateRecognitionLanguageConfig() {
        if (!recognitionLanguageSelect) {
          return;
        }

        const selectedOption = recognitionLanguageSelect.selectedOptions[0];
        const selectedLocale = recognitionLanguageSelect.value;
        const optionLanguage =
          selectedOption?.dataset?.transcribe || selectedLocale.split("-")[0];

        advancedConfig.recognitionLocale = selectedLocale || defaultRecognitionLocale;
        advancedConfig.language = optionLanguage || "";
      }

      function syncAdvancedInputsWithConfig() {
        if (advancedModelSizeSelect) {
          const options = Array.from(advancedModelSizeSelect.options);
          if (!options.find((option) => option.value === advancedConfig.modelSize)) {
            advancedConfig.modelSize = defaultAdvancedConfig.modelSize;
          }
          advancedModelSizeSelect.value = advancedConfig.modelSize;
        }

        if (advancedComputeTypeSelect) {
          const options = Array.from(advancedComputeTypeSelect.options);
          if (!options.find((option) => option.value === advancedConfig.computeType)) {
            advancedConfig.computeType = defaultAdvancedConfig.computeType;
          }
          advancedComputeTypeSelect.value = advancedConfig.computeType;
        }

        if (recognitionLanguageSelect) {
          const options = Array.from(recognitionLanguageSelect.options);
          const matchingOption = options.find(
            (option) => option.value === advancedConfig.recognitionLocale,
          );

          if (matchingOption) {
            recognitionLanguageSelect.value = advancedConfig.recognitionLocale;
          } else if (options.length > 0) {
            recognitionLanguageSelect.value = options[0].value;
            updateRecognitionLanguageConfig();
          }
        }

        if (vadFilterToggle) {
          vadFilterToggle.checked = Boolean(advancedConfig.vadFilter);
        }

        if (ttsVoiceSelect) {
          const selectedValue = advancedConfig.ttsVoice || "";
          ttsVoiceSelect.value = selectedValue;
        }
      }

      syncAdvancedInputsWithConfig();
      updateRecognitionLanguageConfig();
      persistAdvancedConfig(advancedConfig);

      if (advancedSettingsToggle && advancedSettingsPanel) {
        updateAdvancedToggleText();
        advancedSettingsToggle.addEventListener("click", () => {
          advancedSettingsPanel.classList.toggle("hidden");
          updateAdvancedToggleText();
        });
      }

      if (languageButtons.length) {
        languageButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const targetLang = button.dataset.language || "en";
            setUiLanguage(targetLang);
          });
        });
      }

      if (advancedModelSizeSelect) {
        advancedModelSizeSelect.addEventListener("change", (event) => {
          advancedConfig.modelSize = event.target.value || defaultAdvancedConfig.modelSize;
          persistAdvancedConfig(advancedConfig);
        });
      }

      if (advancedComputeTypeSelect) {
        advancedComputeTypeSelect.addEventListener("change", (event) => {
          advancedConfig.computeType = event.target.value || "";
          persistAdvancedConfig(advancedConfig);
        });
      }

      if (recognitionLanguageSelect) {
        recognitionLanguageSelect.addEventListener("change", () => {
          const previousLanguage = advancedConfig?.language || "";
          updateRecognitionLanguageConfig();
          persistAdvancedConfig(advancedConfig);
          const nextLanguage = advancedConfig?.language || "";
          if (previousLanguage !== nextLanguage) {
            handlePracticeLanguageChange();
          } else {
            rebuildParagraphOptions(paragraphSelect.value);
          }
        });
      }

      if (vadFilterToggle) {
        vadFilterToggle.addEventListener("change", (event) => {
          advancedConfig.vadFilter = Boolean(event.target.checked);
          persistAdvancedConfig(advancedConfig);
        });
      }

      function populateTtsVoiceOptions() {
        if (!ttsVoiceSelect) {
          return;
        }

        if (!supportsSpeechSynthesis || !synth) {
          if (voiceRetryTimeoutId !== null) {
            window.clearTimeout(voiceRetryTimeoutId);
            voiceRetryTimeoutId = null;
          }
          ttsVoiceSelect.innerHTML = "";
          const option = document.createElement("option");
          option.value = "";
          option.textContent = t("ttsVoiceUnavailable");
          ttsVoiceSelect.append(option);
          ttsVoiceSelect.disabled = true;
          return;
        }

        const voices = (synth?.getVoices?.() || []).slice().sort((a, b) => {
          const nameCompare = a.name.localeCompare(b.name, undefined, {
            sensitivity: "base",
          });
          if (nameCompare !== 0) return nameCompare;
          return a.lang.localeCompare(b.lang, undefined, { sensitivity: "base" });
        });

        ttsVoiceSelect.innerHTML = "";

        if (voices.length === 0) {
          const loadingOption = document.createElement("option");
          loadingOption.value = "";
          loadingOption.textContent = t("ttsVoiceDefault");
          ttsVoiceSelect.append(loadingOption);
          ttsVoiceSelect.disabled = true;
          if (voiceRetryTimeoutId === null) {
            voiceRetryTimeoutId = window.setTimeout(() => {
              voiceRetryTimeoutId = null;
              synth?.getVoices?.();
              populateTtsVoiceOptions();
            }, 500);
          }
          return;
        }

        if (voiceRetryTimeoutId !== null) {
          window.clearTimeout(voiceRetryTimeoutId);
          voiceRetryTimeoutId = null;
        }
        ttsVoiceSelect.disabled = false;

        const defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.textContent = t("ttsVoiceDefault");
        ttsVoiceSelect.append(defaultOption);

        voices.forEach((voice) => {
          const option = document.createElement("option");
          option.value = voice.voiceURI;
          option.textContent = `${voice.name} (${voice.lang}${voice.localService ? " ¬∑ local" : ""})`;
          ttsVoiceSelect.append(option);
        });

        const storedVoice = advancedConfig.ttsVoice || "";
        const voiceExists = voices.some((voice) => voice.voiceURI === storedVoice);
        if (voiceExists) {
          ttsVoiceSelect.value = storedVoice;
        } else {
          ttsVoiceSelect.value = "";
          if (storedVoice) {
            advancedConfig.ttsVoice = "";
            persistAdvancedConfig(advancedConfig);
          }
        }
      }

      if (ttsVoiceSelect) {
        if (synth && typeof synth.addEventListener === "function") {
          synth.addEventListener("voiceschanged", populateTtsVoiceOptions);
        } else if (synth) {
          synth.onvoiceschanged = populateTtsVoiceOptions;
        }

        if (synth && typeof synth.getVoices === "function") {
          synth.getVoices();
        }

        populateTtsVoiceOptions();

        ttsVoiceSelect.addEventListener("change", (event) => {
          advancedConfig.ttsVoice = event.target.value || "";
          persistAdvancedConfig(advancedConfig);
        });
      }
      const customEntries = [createCustomEntry(CUSTOM_OPTION_ID, "base", 1)];
      const customTexts = new Map([[CUSTOM_OPTION_ID, ""]]);
      let customEntryCount = 1;

      const PRESET_PARAGRAPHS = {
        en: [
          {
            id: "seashells",
            label: "She sells seashells",
            text:
              "She sells seashells by the seashore; the shells she sells are surely seashells.",
          },
          {
            id: "peter-piper",
            label: "Peter Piper",
            text:
              "Peter Piper picked a peck of pickled peppers; a peck of pickled peppers Peter Piper picked.",
          },
          {
            id: "clam-can",
            label: "Clean cream can",
            text: "How can a clam cram in a clean cream can?",
          },
          {
            id: "susie-shoeshine",
            label: "Susie in a shoeshine shop",
            text: "I saw Susie sitting in a shoeshine shop.",
          },
          {
            id: "pad-kid",
            label: "Pad kid poured",
            text: "Pad kid poured curd pulled cod.",
          },
          {
            id: "fred-ted",
            label: "Fred fed Ted",
            text: "Fred fed Ted bread and Ted fed Fred bread.",
          },
          {
            id: "black-bug",
            label: "Big black bug",
            text: "A big black bug bit a big black bear.",
          },
          {
            id: "unique-new-york",
            label: "Unique New York",
            text:
              "Unique New York, unique New York, you know you need unique New York.",
          },
          {
            id: "sleek-swans",
            label: "Six sleek swans",
            text: "Six sleek swans swam swiftly southwards.",
          },
          {
            id: "irish-wristwatch",
            label: "Irish wristwatch",
            text: "Irish wristwatch, Swiss wristwatch.",
          },
          {
            id: "lorry",
            label: "Red lorry, yellow lorry",
            text: "Red lorry, yellow lorry, red lorry, yellow lorry.",
          },
          {
            id: "toy-boat",
            label: "Toy boat",
            text: "Toy boat, toy boat, toy boat, toy boat, toy boat.",
          },
          {
            id: "fuzzy-wuzzy",
            label: "Fuzzy Wuzzy",
            text: "Fuzzy Wuzzy was a bear; Fuzzy Wuzzy had no hair.",
          },
          {
            id: "proper-copper",
            label: "Proper copper coffee pot",
            text: "A proper copper coffee pot.",
          },
          {
            id: "woodchuck",
            label: "Woodchuck",
            text: "How much wood would a woodchuck chuck if a woodchuck could chuck wood?",
          },
          {
            id: "thirty-three",
            label: "Thirty-three thousand",
            text: "Thirty-three thousand feathers on a thrush's throat.",
          },
        ],
        ca: [
          {
            id: "ca-setze-jutges",
            label: "Setze jutges",
            text: "Setze jutges d'un jutjat mengen fetge d'un penjat.",
          },
          {
            id: "ca-plou-poc",
            label: "Plou poc per√≤ prou",
            text: "Plou poc per√≤ pel poc que plou plou prou.",
          },
          {
            id: "ca-reina-riu",
            label: "La reina que riu",
            text: "La reina de les reines riu i fa riure als s√∫bdits.",
          },
          {
            id: "ca-xai-xines",
            label: "El xai xin√®s",
            text: "El xai xin√®s √©s xin√®s i no pas de X√†tiva.",
          },
          {
            id: "ca-bruixes",
            label: "Vuit bruixes",
            text: "Vuit bruixes bruixetes bruixegen bruixeries.",
          },
        ],
        fr: [
          {
            id: "fr-chasseur",
            label: "Chasseur sans chien",
            text: "Un chasseur sachant chasser sans son chien est un bon chasseur.",
          },
          {
            id: "fr-archiduchesse",
            label: "Chaussettes de l'archiduchesse",
            text: "Les chaussettes de l'archiduchesse sont-elles s√®ches ? Archi-s√®ches.",
          },
          {
            id: "fr-six-scies",
            label: "Six scies scient",
            text: "Si six scies scient six cypr√®s, six cents scies scient six cents cypr√®s.",
          },
          {
            id: "fr-jasmin",
            label: "Je veux du jasmin",
            text: "Je veux et j'exige du jasmin et des jonquilles dans mon jardin.",
          },
          {
            id: "fr-dragon",
            label: "Dragon grad√©",
            text: "Un dragon grad√© d√©grade un dragon d√©grad√©.",
          },
        ],
        it: [
          {
            id: "it-trentini",
            label: "Trentatr√© trentini",
            text: "Trentatr√© trentini entrarono a Trento tutti e trentatr√© trotterellando.",
          },
          {
            id: "it-apelle",
            label: "Apelle figlio di Apollo",
            text: "Apelle figlio di Apollo fece una palla di pelle di pollo.",
          },
          {
            id: "it-capra-panca",
            label: "Capra e panca",
            text: "Sopra la panca la capra campa, sotto la panca la capra crepa.",
          },
          {
            id: "it-arcivescovo",
            label: "Arcivescovo di Costantinopoli",
            text: "Se l'arcivescovo di Costantinopoli si disarcivescoviscostantinopolizzasse, vi disarcivescoviscostantinopolizzereste voi?",
          },
          {
            id: "it-tre-tigri",
            label: "Tre tigri",
            text: "Tre tigri contro tre tigri.",
          },
        ],
        ar: [
          {
            id: "ar-khams-khubzat",
            label: "ÿÆŸÖÿ≥ ÿÆÿ®ÿ≤ÿßÿ™",
            text: "ÿÆŸÖÿ≥ ÿÆÿ®ÿ≤ÿßÿ™ ÿÆŸéÿ®Ÿéÿ≤ŸíŸÜŸé ŸÅŸä ŸÅÿ±ŸÜ ÿÆÿ®ÿßÿ≤.",
          },
          {
            id: "ar-sharh",
            label: "ÿ¥ÿ± ÿ¥ÿßÿ±ÿ≠",
            text: "ÿ¥ÿ± ÿ¥ÿßÿ±ÿ≠ ÿ¥ÿ±ÿ≠ ÿ¥ÿ±ÿ≠Ÿãÿß ÿ∫Ÿäÿ± ŸÖÿ¥ÿ±Ÿàÿ≠.",
          },
          {
            id: "ar-batatuna",
            label: "ÿ®ÿ∑ÿ™ŸÜÿß ÿ®ÿ∑ÿ™",
            text: "ÿ®ÿ∑ÿ™ŸÜÿß ÿ®ÿ∑ÿ™ ÿ®ÿ∑ÿ™ŸÉŸÖÿå ÿ®ÿ∑ÿ™ŸÉŸÖ ÿ®ÿ∑ÿ™ ÿ®ÿ∑ÿ™ŸÜÿß.",
          },
          {
            id: "ar-tabaq",
            label: "ÿ∑ÿ®ŸÇ ÿ∑ÿ®ŸÇŸÜÿß",
            text: "ÿ∑ÿ®ŸÇ ÿ∑ÿ®ŸÇŸÜÿß ÿ∑ÿ®ŸÇÿß ŸÑÿß Ÿäÿ∑ÿ®ŸÇ.",
          },
          {
            id: "ar-sara",
            label: "ÿ≥ÿ± ÿ≥ÿßÿ±ÿß",
            text: "ÿ≥ÿ± ÿ≥ÿßÿ±ÿß ÿ£ÿ≥ÿ±ÿπ ŸÖŸÜ ÿ≥ÿ± ÿ≥ÿßÿ±ÿ©.",
          },
        ],
      };

      function getPracticeLanguage() {
        const configuredLanguage =
          typeof advancedConfig?.language === "string" && advancedConfig.language
            ? advancedConfig.language
            : "";
        if (configuredLanguage) {
          return configuredLanguage;
        }

        if (recognitionLanguageSelect) {
          const selectedOption = recognitionLanguageSelect.selectedOptions?.[0];
          const optionLanguage = selectedOption?.dataset?.transcribe;
          if (optionLanguage) {
            return optionLanguage;
          }
          const fallbackValue = recognitionLanguageSelect.value || "";
          if (fallbackValue) {
            return fallbackValue.split("-")[0];
          }
        }

        return defaultTranscriptionLanguage || "en";
      }

      function getPresetParagraphs() {
        const practiceLanguage = getPracticeLanguage();
        return PRESET_PARAGRAPHS[practiceLanguage] || PRESET_PARAGRAPHS.en;
      }

      let isListening = false;
      let isProcessing = false;
      let mediaRecorder = null;
      let recordedChunks = [];
      let activeStream = null;
      let audioContext = null;
      let recognition = null;
      let recognitionState = null;
      let shouldRestartRecognition = false;
      let activeParagraphId = null;
      let allowWordPlayback = false;
      let hasShownSuccessCelebration = false;

      const API_ENDPOINT = "/api/transcribe";

      function rebuildParagraphOptions(selectedId = CUSTOM_OPTION_ID) {
        const presetParagraphs = getPresetParagraphs();
        paragraphSelect.innerHTML = "";
        customEntries.forEach((entry) => {
          const option = document.createElement("option");
          option.value = entry.id;
          option.textContent = entry.label;
          paragraphSelect.append(option);
        });

        presetParagraphs.forEach((entry) => {
          const option = document.createElement("option");
          option.value = entry.id;
          option.textContent = entry.label;
          paragraphSelect.append(option);
        });

        let nextSelectedId = selectedId;
        if (
          !isCustomParagraphId(nextSelectedId) &&
          !presetParagraphs.some((entry) => entry.id === nextSelectedId)
        ) {
          nextSelectedId = presetParagraphs[0]?.id || CUSTOM_OPTION_ID;
        }

        const matchingOption = Array.from(paragraphSelect.options).find(
          (option) => option.value === nextSelectedId
        );
        if (matchingOption) {
          matchingOption.selected = true;
        } else if (paragraphSelect.options.length) {
          paragraphSelect.options[0].selected = true;
        }
      }

      function populateParagraphs() {
        rebuildParagraphOptions(CUSTOM_OPTION_ID);
        activeParagraphId = CUSTOM_OPTION_ID;
        renderParagraph("");
        resetResultDisplay();
        hideSupportMessage();
      }

      function handlePracticeLanguageChange() {
        const currentSelection = paragraphSelect?.value || CUSTOM_OPTION_ID;
        const presetParagraphs = getPresetParagraphs();
        let nextSelection = currentSelection;
        if (
          !isCustomParagraphId(currentSelection) &&
          !presetParagraphs.some((entry) => entry.id === currentSelection)
        ) {
          nextSelection = presetParagraphs[0]?.id || CUSTOM_OPTION_ID;
        }
        rebuildParagraphOptions(nextSelection);
        displaySelectedParagraph();
        hideSupportMessage();
        resetResultDisplay();
      }

      function setCustomInputMode(customEntry) {
        if (customEntry) {
          customTextInput.setAttribute("contenteditable", "true");
          customTextInput.setAttribute("aria-readonly", "false");
          customTextInput.dataset.placeholder =
            customEntry.placeholder || t("customPlaceholder");
          if (helperText) {
            helperText.textContent = customEntry.helperText || t("customHelper");
          }
        } else {
          customTextInput.setAttribute("contenteditable", "false");
          customTextInput.setAttribute("aria-readonly", "true");
          customTextInput.dataset.placeholder = "";
          if (helperText) {
            helperText.textContent = t("presetHelper");
          }
        }
      }

      function getCustomTextRaw(id = CUSTOM_OPTION_ID) {
        return customTexts.get(id) || "";
      }

      function setCustomText(id, value) {
        customTexts.set(id, value || "");
      }

      function addAnotherCustomEntry() {
        customEntryCount += 1;
        const id = `${CUSTOM_OPTION_ID}-${customEntryCount}`;
        const entry = createCustomEntry(id, "saved", customEntryCount);
        customEntries.push(entry);
        setCustomText(id, "");
        rebuildParagraphOptions(id);
        activeParagraphId = id;
        hideSupportMessage();
        resetResultDisplay();
        renderParagraph("");
        customTextInput.focus();
      }

      function createEmptyStatus() {
        return {
          correctness: "pending",
          provisional: true,
          slow: false,
          repeated: false,
          similarity: 0,
        };
      }

      function getPlaybackWord(word) {
        const cleaned = word.original.replace(/[^\p{L}'-]+/gu, "");
        if (cleaned) return cleaned;
        if (word.cleaned) return word.cleaned;
        return word.original.trim();
      }

      function getCustomEntryById(id) {
        return customEntries.find((entry) => entry.id === id);
      }

      function isCustomParagraphId(id) {
        return Boolean(getCustomEntryById(id));
      }

      function getActivePracticeText() {
        if (recognitionState && typeof recognitionState.targetText === "string") {
          return recognitionState.targetText;
        }

        const selected = getSelectedParagraph();
        if (!selected) {
          return "";
        }

        if (isCustomParagraphId(selected.id)) {
          return getCustomTextRaw(selected.id);
        }

        return selected.text || "";
      }

      function updatePlayButtonState() {
        if (!playTextButton) {
          return;
        }

        if (!supportsSpeechSynthesis || !synth) {
          playTextButton.disabled = true;
          playTextButton.title = t("playButtonTitleNoSpeech");
          return;
        }

        const text = getActivePracticeText().trim();
        const shouldDisable = !text || isListening || isProcessing;
        playTextButton.disabled = shouldDisable;

        if (shouldDisable) {
          playTextButton.title = text
            ? t("playButtonTitleRecording")
            : t("playButtonTitleMissingText");
        } else {
          playTextButton.title = t("playButtonTitleReady");
        }
      }

      function renderParagraph(text, analysis = []) {
        const targetWords = tokenise(text);
        const hasAnalysis = Array.isArray(analysis) && analysis.length > 0;
        customTextInput.innerHTML = "";
        const activeId = activeParagraphId || paragraphSelect.value;
        const customEntry = getCustomEntryById(activeId);

        if (!hasAnalysis || targetWords.length === 0) {
          customTextInput.textContent = text;
          customTextInput.classList.remove("interactive");
          allowWordPlayback = false;
          setCustomInputMode(customEntry);
          if (legendCard) {
            legendCard.classList.remove("active");
            legendCard.setAttribute("aria-hidden", "true");
          }
          updatePlayButtonState();
          return;
        }

        allowWordPlayback = true;
        customTextInput.classList.add("interactive");
        customTextInput.setAttribute("contenteditable", "false");
        customTextInput.setAttribute("aria-readonly", "true");
        if (helperText) {
          helperText.textContent = t("legendHelper");
        }
        if (legendCard) {
          legendCard.classList.remove("active");
          legendCard.setAttribute("aria-hidden", "true");
        }

        targetWords.forEach((word, idx) => {
          const span = document.createElement("span");
          span.textContent = word.original;
          span.dataset.word = getPlaybackWord(word);
          span.tabIndex = 0;
          span.setAttribute("role", "button");

          const status = hasAnalysis
            ? analysis[idx] || createEmptyStatus()
            : createEmptyStatus();

        const wordLabel = span.dataset.word || word.original;
        const feedback = getWordFeedback(status);
        const actionLabel = allowWordPlayback
          ? t("wordPronunciation", wordLabel)
          : t("wordGeneric", wordLabel);

        span.setAttribute(
          "aria-label",
          feedback ? `${actionLabel} ${feedback}` : actionLabel
        );

          if (feedback) {
            span.title = feedback;
            span.dataset.feedback = feedback;
          }

          if (hasAnalysis) {
            span.classList.add(status.correctness);
            if (status.provisional) span.classList.add("provisional");
            if (status.slow) span.classList.add("slow");
            if (status.repeated) span.classList.add("repeated");
          }

          customTextInput.append(span);
          customTextInput.append(document.createTextNode(" "));
        });

        updatePlayButtonState();
      }

      function applyVoiceSettings(utterance, options = {}) {
        if (!utterance || !supportsSpeechSynthesis || !synth) {
          return;
        }

        const { rate = 0.95, pitch = 1 } = options;
        utterance.rate = rate;
        utterance.pitch = pitch;

        const preferredLocale =
          advancedConfig?.recognitionLocale || defaultRecognitionLocale || "en-US";
        let selectedVoice = null;
        if (advancedConfig?.ttsVoice) {
          const availableVoices =
            typeof synth.getVoices === "function" ? synth.getVoices() : [];
          selectedVoice = availableVoices.find(
            (voice) => voice.voiceURI === advancedConfig.ttsVoice,
          );
        }

        if (selectedVoice) {
          utterance.voice = selectedVoice;
          if (selectedVoice.lang) {
            utterance.lang = selectedVoice.lang;
          }
        }

        if (!utterance.lang && preferredLocale) {
          utterance.lang = preferredLocale;
        }
      }

      function playWord(word) {
        if (!word || !allowWordPlayback) return;
        if (!supportsSpeechSynthesis || !synth) return;
        if (synth.speaking) synth.cancel();
        const utterance = new SpeechSynthesisUtterance(word);
        applyVoiceSettings(utterance);
        synth.speak(utterance);
      }

      function playParagraphText() {
        if (!supportsSpeechSynthesis || !synth) return;
        if (isListening || isProcessing) return;
        const text = getActivePracticeText().trim();
        if (!text) return;
        if (synth.speaking) {
          synth.cancel();
        }
        const utterance = new SpeechSynthesisUtterance(text);
        applyVoiceSettings(utterance, { rate: 0.98 });
        synth.speak(utterance);
      }

      function tokenise(text) {
        const words = text
          .trim()
          .split(/\s+/)
          .map((raw) => {
            const cleaned = raw
              .toLowerCase()
              .replace(/^[^a-z√†-√ø']+|[^a-z√†-√ø']+$/gi, "");
            return { original: raw.replace(/\s+/g, " "), cleaned };
          })
          .filter((token) => token.cleaned.length);
        return words;
      }

      function getSelectedParagraph() {
        const selectedId = paragraphSelect.value;
        const customEntry = getCustomEntryById(selectedId);
        if (customEntry) {
          return {
            id: customEntry.id,
            label: customEntry.label,
            text: getCustomTextRaw(customEntry.id),
          };
        }

        const presetParagraphs = getPresetParagraphs();
        const chosen = presetParagraphs.find((p) => p.id === selectedId);
        if (chosen) return chosen;

        return {
          id: CUSTOM_OPTION_ID,
          label: customEntries[0]?.label || "Custom text",
          text: getCustomTextRaw(CUSTOM_OPTION_ID),
        };
      }

      function displaySelectedParagraph() {
        const selected = getSelectedParagraph();
        activeParagraphId = selected.id;
        const textToShow =
          isCustomParagraphId(selected.id)
            ? getCustomTextRaw(selected.id)
            : selected.text;
        renderParagraph(textToShow || "");
      }

      function normaliseTranscript(text) {
        return text
          .toLowerCase()
          .replace(/[^a-z√†-√ø'\s]/gi, "")
          .trim()
          .split(/\s+/)
          .filter(Boolean);
      }

      function calculateSimilarity(a, b) {
        if (!a || !b) return 0;
        if (a === b) return 1;
        const rows = a.length + 1;
        const cols = b.length + 1;
        const dp = Array.from({ length: rows }, (_, i) => {
          const row = new Array(cols).fill(0);
          row[0] = i;
          return row;
        });
        for (let j = 0; j < cols; j += 1) {
          dp[0][j] = j;
        }
        for (let i = 1; i < rows; i += 1) {
          for (let j = 1; j < cols; j += 1) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            dp[i][j] = Math.min(
              dp[i - 1][j] + 1,
              dp[i][j - 1] + 1,
              dp[i - 1][j - 1] + cost
            );
          }
        }
        const distance = dp[rows - 1][cols - 1];
        const maxLen = Math.max(a.length, b.length);
        if (maxLen === 0) return 1;
        return (maxLen - distance) / maxLen;
      }

      function findBestMatchIndex(target, spokenWords, startIndex) {
        let bestIndex = -1;
        let bestSimilarity = 0;
        for (let idx = startIndex; idx < spokenWords.length; idx += 1) {
          const candidate = spokenWords[idx];
          if (!candidate) continue;
          if (candidate === target) {
            return { index: idx, similarity: 1 };
          }
          const distanceFromStart = idx - startIndex;
          const similarity = calculateSimilarity(target, candidate);
          if (
            similarity >= CLOSE_SIMILARITY_THRESHOLD &&
            similarity > bestSimilarity &&
            distanceFromStart <= MATCH_LOOKAHEAD_LIMIT
          ) {
            bestIndex = idx;
            bestSimilarity = similarity;
          }
          if (distanceFromStart > MATCH_LOOKAHEAD_LIMIT && bestIndex !== -1) {
            break;
          }
        }
        if (bestIndex === -1) {
          return { index: -1, similarity: 0 };
        }
        return { index: bestIndex, similarity: bestSimilarity };
      }

      function evaluatePronunciation(targetWords, spokenWords, options = {}) {
        const {
          confirmedCount = 0,
          metadata = [],
          awaitingMore = false,
          isComplete = false,
        } = options;
        const analysis = [];
        let spokenIndex = 0;
        const noPendingTokens = !awaitingMore && confirmedCount === spokenWords.length;
        for (let i = 0; i < targetWords.length; i += 1) {
          const status = createEmptyStatus();
          const target = targetWords[i].cleaned;
          if (spokenIndex >= spokenWords.length) {
            if (noPendingTokens || isComplete) {
              status.correctness = "incorrect";
              status.provisional = false;
            }
            analysis.push(status);
            continue;
          }

          const { index: matchIndex, similarity } = findBestMatchIndex(
            target,
            spokenWords,
            spokenIndex
          );

          if (matchIndex === -1) {
            if (noPendingTokens || isComplete) {
              status.correctness = "incorrect";
              status.provisional = false;
            }
            analysis.push(status);
            continue;
          }

          const isConfirmed = matchIndex < confirmedCount;
          const holdOpen = awaitingMore && !isComplete;
          status.provisional = holdOpen || !isConfirmed;
          status.similarity = similarity;

          if (similarity === 1) {
            status.correctness = "correct";
          } else if (similarity >= CLOSE_SIMILARITY_THRESHOLD) {
            status.correctness = "close";
          } else {
            status.correctness = "incorrect";
          }

          if (isConfirmed) {
            const meta = metadata[matchIndex];
            status.slow = Boolean(meta?.slow);
            if (meta?.repeated) {
              const previousTarget = targetWords[i - 1]?.cleaned || "";
              const isTargetRepeat = previousTarget && previousTarget === target;
              status.repeated = !isTargetRepeat;
            } else {
              status.repeated = false;
            }
          }

          spokenIndex = matchIndex + 1;
          analysis.push(status);
        }
        return analysis;
      }

      function alignSpokenTokens(targetWords, spokenWords = [], options = {}) {
        const {
          confirmedCount = 0,
          awaitingMore = false,
          isComplete = false,
        } = options;
        const alignedTokens = [];
        let alignmentFailed = false;
        let spokenIndex = 0;

        if (!Array.isArray(targetWords) || !targetWords.length) {
          return {
            tokens: alignedTokens,
            alignmentFailed,
          };
        }

        const noPendingTokens =
          !awaitingMore && confirmedCount === spokenWords.length;

        for (let i = 0; i < targetWords.length; i += 1) {
          const target = targetWords[i]?.cleaned;
          if (!target) {
            continue;
          }

          if (spokenIndex >= spokenWords.length) {
            if (noPendingTokens || isComplete) {
              alignmentFailed = true;
            }
            break;
          }

          const { index: matchIndex } = findBestMatchIndex(
            target,
            spokenWords,
            spokenIndex
          );

          if (matchIndex === -1) {
            if (noPendingTokens || isComplete) {
              alignmentFailed = true;
            }
            break;
          }

          alignedTokens.push(spokenWords[matchIndex]);
          spokenIndex = matchIndex + 1;
        }

        if (isComplete && alignedTokens.length !== targetWords.length) {
          alignmentFailed = true;
        }

        return {
          tokens: alignedTokens,
          alignmentFailed,
        };
      }

      function isPerfectPronunciation(targetWords, analysis) {
        if (!Array.isArray(targetWords) || !Array.isArray(analysis)) {
          return false;
        }
        if (!targetWords.length) {
          return false;
        }
        const relevantAnalysis = analysis.slice(0, targetWords.length);
        if (relevantAnalysis.length < targetWords.length) {
          return false;
        }
        return relevantAnalysis.every(
          (status) => status && status.correctness === "correct",
        );
      }

      function getWordFeedback(status) {
        if (!status) return "";
        const messages = [];

        switch (status.correctness) {
          case "correct":
            messages.push(t("feedbackCorrect"));
            break;
          case "close":
            messages.push(t("feedbackClose"));
            break;
          case "incorrect":
            messages.push(t("feedbackIncorrect"));
            break;
          case "pending":
          default:
            messages.push(t("feedbackPending"));
            break;
        }

        if (status.correctness !== "pending" && status.provisional) {
          messages.push(t("feedbackProvisional"));
        }

        if (status.slow) {
          messages.push(t("feedbackSlow"));
        }

        if (status.repeated) {
          messages.push(t("feedbackRepeated"));
        }

        return messages.join(" ");
      }

      function showSupportMessage(message) {
        supportMessage.textContent = message;
        supportMessage.classList.remove("hidden");
      }

      function hideSupportMessage() {
        supportMessage.classList.add("hidden");
        supportMessage.textContent = "";
      }

      function hideSuccessCelebration() {
        if (!successModal) {
          return;
        }
        successModal.classList.add("hidden");
        successModal.classList.remove("active");
        successModal.setAttribute("aria-hidden", "true");
      }

      function resetSuccessCelebration() {
        hasShownSuccessCelebration = false;
        hideSuccessCelebration();
      }

      function showSuccessCelebration() {
        stopListening();
        if (!successModal || hasShownSuccessCelebration) {
          return;
        }
        successModal.classList.remove("hidden");
        successModal.classList.add("active");
        successModal.removeAttribute("aria-hidden");
        hasShownSuccessCelebration = true;
        if (successModalClose) {
          successModalClose.focus();
        }
      }

      function resetResultDisplay() {
        resultContainer.classList.add("hidden");
        transcriptEl.textContent = "‚Äî";
        recognitionState = null;
        resetSuccessCelebration();
        updatePlayButtonState();
      }

      function toggleListening(isActive) {
        if (isActive) {
          listeningLabel.classList.remove("hidden");
        } else {
          listeningLabel.classList.add("hidden");
        }
        updatePlayButtonState();
      }

      function toggleProcessing(isActive) {
        if (isActive) {
          processingLabel.classList.remove("hidden");
        } else {
          processingLabel.classList.add("hidden");
        }
        updatePlayButtonState();
      }

      function getPreferredMimeType() {
        const preferred = [
          "audio/webm;codecs=opus",
          "audio/ogg;codecs=opus",
          "audio/webm",
        ];
        for (const type of preferred) {
          if (type && MediaRecorder.isTypeSupported(type)) {
            return type;
          }
        }
        return "";
      }

      function prepareParagraphSession(paragraph, { showTranscript } = { showTranscript: false }) {
        activeParagraphId = paragraph.id;
        if (isCustomParagraphId(paragraph.id)) {
          setCustomText(paragraph.id, paragraph.text);
        }
        resetSuccessCelebration();
        const targetTokens = tokenise(paragraph.text);
        recognitionState = {
          paragraphId: paragraph.id,
          paragraphLabel: paragraph.label || "",
          targetText: paragraph.text,
          targetTokens,
          lockedAnalysis: targetTokens.map(() => null),
          confirmedMeta: [],
          confirmedTokens: [],
        };
        renderParagraph(paragraph.text);
        transcriptEl.textContent = showTranscript
          ? t("transcriptPending")
          : t("transcriptPlaceholder");
        if (showTranscript) {
          resultContainer.classList.remove("hidden");
        } else {
          resultContainer.classList.add("hidden");
        }
      }

      function mergeAnalysisWithLocks(analysis) {
        if (!recognitionState) return analysis;
        const { lockedAnalysis, targetTokens } = recognitionState;
        return targetTokens.map((_, idx) => {
          const current = analysis[idx] || createEmptyStatus();
          const locked = lockedAnalysis[idx];

          if (current.provisional || current.correctness === "pending") {
            if (locked) {
              lockedAnalysis[idx] = null;
            }
            return current;
          }

          if (!locked) {
            lockedAnalysis[idx] = { ...current, provisional: false };
            return lockedAnalysis[idx];
          }

          lockedAnalysis[idx] = {
            ...locked,
            ...current,
            provisional: false,
          };
          return lockedAnalysis[idx];
        });
      }

      function determineTokensToAppend(existingTokens, newTokens) {
        if (!newTokens.length) return [];

        if (newTokens.length >= existingTokens.length) {
          const prefixMatches = existingTokens.every(
            (token, idx) => token === newTokens[idx]
          );
          if (prefixMatches) {
            return newTokens.slice(existingTokens.length);
          }
        }

        const maxOverlap = Math.min(existingTokens.length, newTokens.length);
        for (let overlap = maxOverlap; overlap > 0; overlap -= 1) {
          const existingSuffix = existingTokens.slice(
            existingTokens.length - overlap
          );
          const newPrefix = newTokens.slice(0, overlap);
          const matches = existingSuffix.every(
            (token, idx) => token === newPrefix[idx]
          );
          if (matches) {
            return newTokens.slice(overlap);
          }
        }

        return newTokens;
      }

      function trimInterimOverlap(confirmedTokens, interimTokens) {
        if (!confirmedTokens.length || !interimTokens.length) {
          return interimTokens;
        }

        let trimmedTokens = interimTokens.slice();
        let overlapFound = true;

        while (overlapFound && trimmedTokens.length) {
          overlapFound = false;
          const maxOverlap = Math.min(confirmedTokens.length, trimmedTokens.length);
          for (let overlap = maxOverlap; overlap > 0; overlap -= 1) {
            const confirmedSuffix = confirmedTokens.slice(
              confirmedTokens.length - overlap
            );
            const interimPrefix = trimmedTokens.slice(0, overlap);
            const matches = confirmedSuffix.every(
              (token, idx) => token === interimPrefix[idx]
            );
            if (matches) {
              trimmedTokens = trimmedTokens.slice(overlap);
              overlapFound = true;
              break;
            }
          }
        }

        return trimmedTokens;
      }

      function handleRecognitionResult(event) {
        if (!recognitionState) return;
        const { targetTokens, targetText } = recognitionState;
        const recognitionResults = Array.from(event.currentTarget?.results || event.results || []);
        const finalTranscript = recognitionResults
          .filter((result) => result.isFinal)
          .map((result) => result[0].transcript)
          .join(" ")
          .trim();
        const interimTranscript = recognitionResults
          .filter((result) => !result.isFinal)
          .map((result) => result[0].transcript)
          .join(" ")
          .trim();

        const finalTokens = normaliseTranscript(finalTranscript);
        const interimTokens = normaliseTranscript(interimTranscript);

        let confirmedTokens = recognitionState.confirmedTokens;
        if (!Array.isArray(confirmedTokens)) {
          confirmedTokens = [];
          recognitionState.confirmedTokens = confirmedTokens;
        }

        let confirmedMeta = recognitionState.confirmedMeta;
        if (!Array.isArray(confirmedMeta)) {
          confirmedMeta = [];
          recognitionState.confirmedMeta = confirmedMeta;
        }

        const tokensToAppend = determineTokensToAppend(confirmedTokens, finalTokens);

        if (tokensToAppend.length) {
          const now =
            typeof performance !== "undefined" && performance.now
              ? performance.now()
              : Date.now();
          for (const token of tokensToAppend) {
            const previous = confirmedMeta[confirmedMeta.length - 1] || null;
            const delta = previous ? Math.max(0, now - previous.timestamp) : 0;
            const entry = {
              word: token,
              timestamp: now,
              slow: previous ? delta > SLOW_WORD_THRESHOLD_MS : false,
              repeated: previous ? previous.word === token : false,
            };
            confirmedMeta.push(entry);
            confirmedTokens.push(token);
          }
          recognitionState.confirmedMeta = confirmedMeta;
          recognitionState.confirmedTokens = confirmedTokens;
        }

        const trimmedInterimTokens = trimInterimOverlap(
          confirmedTokens,
          interimTokens
        );
        const combinedTokens = confirmedTokens.concat(trimmedInterimTokens);
        const analysis = evaluatePronunciation(targetTokens, combinedTokens, {
          confirmedCount: confirmedTokens.length,
          metadata: confirmedMeta,
          awaitingMore: isListening || trimmedInterimTokens.length > 0,
        });
        const mergedAnalysis = mergeAnalysisWithLocks(analysis);
        renderParagraph(targetText, mergedAnalysis);

        const hasSpokenAllTargets =
          confirmedTokens.length >= targetTokens.length && targetTokens.length > 0;
        const analysisSlice = hasSpokenAllTargets
          ? mergedAnalysis.slice(0, targetTokens.length)
          : [];
        const completedSuccessfully = isPerfectPronunciation(
          targetTokens,
          analysisSlice,
        );

        if (completedSuccessfully) {
          showSuccessCelebration();
        }

        const confirmedTranscript = confirmedTokens.join(" ");
        const trimmedInterimTranscript = trimmedInterimTokens.join(" ");
        const fallbackTranscript = [
          confirmedTranscript,
          trimmedInterimTranscript,
        ]
          .filter(Boolean)
          .join(" ")
          .trim();
        const alignment = alignSpokenTokens(targetTokens, combinedTokens, {
          confirmedCount: confirmedTokens.length,
          awaitingMore: isListening || trimmedInterimTokens.length > 0,
        });
        const alignedTranscript = alignment.tokens.join(" ").trim();
        transcriptEl.textContent =
          alignment.alignmentFailed || !alignedTranscript
            ? fallbackTranscript || t("transcriptPending")
            : alignedTranscript;
        resultContainer.classList.remove("hidden");
      }

      function finaliseRecognitionAttempt() {
        if (!recognitionState) {
          return;
        }
        const {
          paragraphId,
          paragraphLabel,
          targetText,
          targetTokens,
          confirmedTokens: storedTokens,
          confirmedMeta,
        } = recognitionState;
        if (!Array.isArray(targetTokens) || !targetTokens.length) {
          return;
        }
        const confirmedTokens = Array.isArray(storedTokens)
          ? storedTokens.slice()
          : [];
        const paragraph = {
          id: paragraphId || CUSTOM_OPTION_ID,
          label: paragraphLabel || "",
          text: targetText || "",
        };
        const analysis = evaluatePronunciation(targetTokens, confirmedTokens, {
          confirmedCount: confirmedTokens.length,
          metadata: Array.isArray(confirmedMeta) ? confirmedMeta : [],
          isComplete: true,
        });
        const mergedAnalysis = mergeAnalysisWithLocks(analysis);
        recordPracticeHistory(paragraph, targetTokens, mergedAnalysis);
      }

      function startSpeechRecognition() {
        try {
          recognition = new SpeechRecognition();
        } catch (error) {
          console.error(error);
          showSupportMessage(t("recognitionUnavailable"));
          return false;
        }

        updateRecognitionLanguageConfig();

        const recognitionLocale =
          (advancedConfig && advancedConfig.recognitionLocale) ||
          navigator.language ||
          "en-US";
        recognition.lang = recognitionLocale;
        recognition.interimResults = true;
        recognition.continuous = true;
        shouldRestartRecognition = true;

        recognition.onresult = handleRecognitionResult;
        recognition.onstart = () => {
          isListening = true;
          toggleListening(true);
          startButton.disabled = true;
          stopButton.disabled = false;
        };
        recognition.onend = () => {
          toggleListening(false);
          isListening = false;
          if (shouldRestartRecognition) {
            try {
              recognition.start();
            } catch (error) {
              console.error(error);
              shouldRestartRecognition = false;
              startButton.disabled = false;
              stopButton.disabled = true;
            }
          } else {
            finaliseRecognitionAttempt();
            startButton.disabled = false;
            stopButton.disabled = true;
            recognition = null;
          }
        };
        recognition.onerror = (event) => {
          console.error(event);
          isListening = false;
          toggleListening(false);
          showSupportMessage(
            event.error === "not-allowed"
              ? t("microphonePermissionDenied")
              : t("speechRecognitionIssue")
          );
          shouldRestartRecognition = false;
          startButton.disabled = false;
          stopButton.disabled = true;
          try {
            recognition.stop();
          } catch (error) {
            console.error(error);
          }
        };

        try {
          recognition.start();
        } catch (error) {
          console.error(error);
          shouldRestartRecognition = false;
          showSupportMessage(t("speechRecognitionStartError"));
          startButton.disabled = false;
          stopButton.disabled = true;
          return false;
        }

        return true;
      }

      async function startMediaRecorderSession(paragraph) {
        if (typeof MediaRecorder === "undefined") {
          showSupportMessage(
            t("mediaRecorderUnsupported")
          );
          startButton.disabled = true;
          stopButton.disabled = true;
          return;
        }

        try {
          activeStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } catch (error) {
          showSupportMessage(
            error.name === "NotAllowedError"
              ? t("microphonePermissionDenied")
              : t("microphoneUnavailable")
          );
          return;
        }

        recordedChunks = [];
        const mimeType = getPreferredMimeType();
        try {
          mediaRecorder = new MediaRecorder(activeStream, mimeType ? { mimeType } : undefined);
        } catch (error) {
          showSupportMessage(t("recorderFailed"));
          activeStream.getTracks().forEach((track) => track.stop());
          activeStream = null;
          return;
        }

        mediaRecorder.addEventListener("dataavailable", (event) => {
          if (event.data && event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        });

        mediaRecorder.addEventListener("stop", handleRecordingStop);

        mediaRecorder.start(1000);
        isListening = true;
        toggleListening(true);
        startButton.disabled = true;
        stopButton.disabled = false;
      }

      async function startListening() {
        if (isListening || isProcessing) return;
        hideSupportMessage();

        const selectedParagraph = getSelectedParagraph();
        activeParagraphId = selectedParagraph.id;

        if (
          isCustomParagraphId(selectedParagraph.id) &&
          !selectedParagraph.text.trim()
        ) {
          renderParagraph(getCustomTextRaw(selectedParagraph.id) || "");
          showSupportMessage(
            t("customTextRequired")
          );
          customTextInput.focus();
          return;
        }

        if (supportsSpeechRecognition) {
          prepareParagraphSession(selectedParagraph, { showTranscript: true });
          const started = startSpeechRecognition();
          if (!started) {
            prepareParagraphSession(selectedParagraph, { showTranscript: false });
            await startMediaRecorderSession(selectedParagraph);
          }
        } else {
          prepareParagraphSession(selectedParagraph, { showTranscript: false });
          await startMediaRecorderSession(selectedParagraph);
        }
      }

      function stopListening() {
        if (recognition) {
          shouldRestartRecognition = false;
          isListening = false;
          try {
            recognition.stop();
          } catch (error) {
            console.error(error);
          }
          stopButton.disabled = true;
          return;
        }

        if (!mediaRecorder || mediaRecorder.state === "inactive") return;
        mediaRecorder.stop();
        stopButton.disabled = true;
        if (activeStream) {
          activeStream.getTracks().forEach((track) => track.stop());
          activeStream = null;
        }
      }

      async function handleRecordingStop() {
        isListening = false;
        toggleListening(false);
        stopButton.disabled = true;
        startButton.disabled = true;

        if (!recordedChunks.length) {
          showSupportMessage(t("noAudioCaptured"));
          startButton.disabled = false;
          return;
        }

        try {
          isProcessing = true;
          toggleProcessing(true);
          const wavBlob = await convertChunksToWav(recordedChunks);
          await submitForTranscription(wavBlob);
        } catch (error) {
          console.error(error);
          showSupportMessage(
            error?.message || t("processingErrorFallback")
          );
        } finally {
          isProcessing = false;
          toggleProcessing(false);
          startButton.disabled = false;
          recordedChunks = [];
          mediaRecorder = null;
        }
      }

      async function convertChunksToWav(chunks) {
        const blob = new Blob(chunks);
        const arrayBuffer = await blob.arrayBuffer();
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
        return audioBufferToWav(audioBuffer);
      }

      function audioBufferToWav(audioBuffer) {
        const sampleRate = audioBuffer.sampleRate;
        const channelData = [];
        for (let i = 0; i < audioBuffer.numberOfChannels; i += 1) {
          channelData.push(audioBuffer.getChannelData(i));
        }

        const length = audioBuffer.length;
        const combined = new Float32Array(length);
        if (channelData.length === 1) {
          combined.set(channelData[0]);
        } else {
          for (let i = 0; i < length; i += 1) {
            let total = 0;
            for (let c = 0; c < channelData.length; c += 1) {
              total += channelData[c][i];
            }
            combined[i] = total / channelData.length;
          }
        }

        const buffer = new ArrayBuffer(44 + length * 2);
        const view = new DataView(buffer);

        function writeString(offset, string) {
          for (let i = 0; i < string.length; i += 1) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        }

        writeString(0, "RIFF");
        view.setUint32(4, 36 + length * 2, true);
        writeString(8, "WAVE");
        writeString(12, "fmt ");
        view.setUint32(16, 16, true); // PCM chunk size
        view.setUint16(20, 1, true); // format (PCM)
        view.setUint16(22, 1, true); // mono
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true); // byte rate
        view.setUint16(32, 2, true); // block align
        view.setUint16(34, 16, true); // bits per sample
        writeString(36, "data");
        view.setUint32(40, length * 2, true);

        let offset = 44;
        for (let i = 0; i < length; i += 1) {
          let sample = combined[i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
          offset += 2;
        }

        return new Blob([buffer], { type: "audio/wav" });
      }

      async function submitForTranscription(wavBlob) {
        updateRecognitionLanguageConfig();

        const formData = new FormData();
        formData.append("audio", wavBlob, "practice.wav");
        const modelSize = advancedConfig?.modelSize || defaultAdvancedConfig.modelSize;
        const computeType =
          typeof advancedConfig?.computeType === "string"
            ? advancedConfig.computeType
            : defaultAdvancedConfig.computeType;
        const transcriptionLanguage =
          advancedConfig?.language || defaultAdvancedConfig.language;
        const vadFilter = advancedConfig?.vadFilter !== false;

        formData.append("model_size", modelSize);
        formData.append("device", "cpu");
        formData.append("compute_type", computeType);
        formData.append("language", transcriptionLanguage);
        formData.append("vad_filter", vadFilter ? "true" : "false");

        const response = await fetch(API_ENDPOINT, {
          method: "POST",
          body: formData,
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(errorText || t("transcriptionRequestFailed"));
        }

        const payload = await response.json();
        handleTranscriptionResult(payload);
      }

      function handleTranscriptionResult(payload) {
        const transcript = (payload?.text || "").trim();
        const paragraph =
          recognitionState && recognitionState.targetText
            ? {
                id: recognitionState.paragraphId || activeParagraphId || CUSTOM_OPTION_ID,
                label: recognitionState.paragraphLabel || "",
                text: recognitionState.targetText,
              }
            : getSelectedParagraph();
        const { text } = paragraph;

        if (!transcript) {
          showSupportMessage(t("noSpeechRecognised"));
          const displayText = isCustomParagraphId(paragraph.id)
            ? getCustomTextRaw(paragraph.id)
            : text;
          renderParagraph(displayText || "");
          return;
        }

        prepareParagraphSession(paragraph, { showTranscript: true });
        hideSupportMessage();
        const targetTokens =
          recognitionState && Array.isArray(recognitionState.targetTokens)
            ? recognitionState.targetTokens
            : tokenise(text);
        const spokenTokens = normaliseTranscript(transcript);
        const analysis = evaluatePronunciation(targetTokens, spokenTokens, {
          confirmedCount: spokenTokens.length,
          isComplete: true,
        });
        const mergedAnalysis = mergeAnalysisWithLocks(analysis);
        renderParagraph(text, mergedAnalysis);
        const alignment = alignSpokenTokens(targetTokens, spokenTokens, {
          confirmedCount: spokenTokens.length,
          isComplete: true,
        });
        const alignedTranscript = alignment.tokens.join(" ").trim();
        transcriptEl.textContent =
          alignment.alignmentFailed || !alignedTranscript
            ? transcript
            : alignedTranscript;
        resultContainer.classList.remove("hidden");
        if (isPerfectPronunciation(targetTokens, mergedAnalysis)) {
          showSuccessCelebration();
        }
        recordPracticeHistory(paragraph, targetTokens, mergedAnalysis);
      }

      paragraphSelect.addEventListener("change", () => {
        displaySelectedParagraph();
        hideSupportMessage();
        resetResultDisplay();
      });

      customTextInput.addEventListener("input", () => {
        const activeId = activeParagraphId || paragraphSelect.value;
        if (!isCustomParagraphId(activeId)) return;
        setCustomText(activeId, customTextInput.textContent);
        hideSupportMessage();
        resetResultDisplay();
      });

      customTextInput.addEventListener("click", (event) => {
        if (!allowWordPlayback) return;
        const target =
          event.target instanceof Element
            ? event.target.closest("span[data-word]")
            : null;
        if (!target) return;
        event.preventDefault();
        playWord(target.dataset.word || target.textContent.trim());
      });

      customTextInput.addEventListener("keydown", (event) => {
        if (!allowWordPlayback) return;
        if (event.key !== "Enter" && event.key !== " ") return;
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const word = target.dataset.word;
        if (!word) return;
        event.preventDefault();
        playWord(word);
      });

      function getPracticeHistoryEntry(key) {
        if (!key) {
          return null;
        }
        return practiceHistoryEntries.find((entry) => entry && entry.key === key);
      }

      function createAnalysisFromSummary(entry) {
        if (!entry || typeof entry.text !== "string") {
          return [];
        }

        const summaryWords = Array.isArray(entry.words) ? entry.words : [];
        const tokenised = tokenise(entry.text);

        return tokenised.map((_, idx) => {
          const summary = summaryWords[idx] || null;
          const correctness = summary?.correctness;
          let normalised = "pending";
          if (correctness === "correct") {
            normalised = "correct";
          } else if (correctness === "close") {
            normalised = "close";
          } else if (correctness === "incorrect") {
            normalised = "incorrect";
          }

          return {
            correctness: normalised,
            provisional: false,
            slow: false,
            repeated: false,
            similarity: normalised === "correct" ? 1 : 0,
          };
        });
      }

      function determineParagraphSelection(entry) {
        if (!entry) {
          return CUSTOM_OPTION_ID;
        }
        const targetId = entry.paragraphId || CUSTOM_OPTION_ID;
        const options = paragraphSelect ? Array.from(paragraphSelect.options) : [];
        const hasOption = options.some((option) => option.value === targetId);
        if (hasOption) {
          return targetId;
        }
        return CUSTOM_OPTION_ID;
      }

      function loadPracticeHistoryEntry(entry) {
        if (!entry || typeof entry.text !== "string") {
          return;
        }

        const text = entry.text.trim();
        if (!text) {
          return;
        }

        const selectedId = determineParagraphSelection(entry);
        if (paragraphSelect) {
          paragraphSelect.value = selectedId;
        }

        activeParagraphId = selectedId;

        if (isCustomParagraphId(selectedId) || selectedId === CUSTOM_OPTION_ID) {
          setCustomText(selectedId, text);
        }

        const analysis = createAnalysisFromSummary(entry);
        renderParagraph(text, analysis);
        resultContainer.classList.remove("hidden");
        transcriptEl.textContent = t("transcriptPlaceholder");
        hideSupportMessage();
      }

      function handleHistoryListClick(event) {
        const target = event.target instanceof Element ? event.target : null;
        if (!target) {
          return;
        }

        const removeButton = target.closest("button.history-remove");
        if (removeButton) {
          const { entryKey } = removeButton.dataset;
          if (!entryKey) {
            return;
          }
          event.preventDefault();
          removePracticeHistoryEntry(entryKey);
          return;
        }

        const card = target.closest(".history-card");
        if (!card) {
          return;
        }

        const entryKey = card.dataset.entryKey;
        if (!entryKey) {
          return;
        }

        const entry = getPracticeHistoryEntry(entryKey);
        if (!entry) {
          return;
        }

        event.preventDefault();
        loadPracticeHistoryEntry(entry);
      }

      function handleHistoryListKeydown(event) {
        if (event.key !== "Enter" && event.key !== " ") {
          return;
        }
        const target = event.target instanceof Element ? event.target : null;
        if (!target) {
          return;
        }

        const card = target.closest(".history-card");
        if (!card) {
          return;
        }

        const entryKey = card.dataset.entryKey;
        if (!entryKey) {
          return;
        }

        event.preventDefault();
        const entry = getPracticeHistoryEntry(entryKey);
        if (!entry) {
          return;
        }
        loadPracticeHistoryEntry(entry);
      }

      if (historyListEl) {
        historyListEl.addEventListener("click", handleHistoryListClick);
        historyListEl.addEventListener("keydown", handleHistoryListKeydown);
      }

      if (addCustomTextButton) {
        addCustomTextButton.addEventListener("click", addAnotherCustomEntry);
      }

      if (playTextButton) {
        playTextButton.addEventListener("click", () => {
          playParagraphText();
        });
      }

      if (successModalClose) {
        successModalClose.addEventListener("click", hideSuccessCelebration);
      }

      if (successModal) {
        successModal.addEventListener("click", (event) => {
          if (event.target === successModal) {
            hideSuccessCelebration();
          }
        });
      }

      document.addEventListener("keydown", (event) => {
        if (event.key !== "Enter") {
          return;
        }
        if (successModal && !successModal.classList.contains("hidden")) {
          event.preventDefault();
          hideSuccessCelebration();
        }
      });

      startButton.addEventListener("click", startListening);
      stopButton.addEventListener("click", stopListening);

      populateParagraphs();
      applyStaticTranslations();
      updatePlayButtonState();
    </script>
  </body>
</html>
